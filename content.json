{"meta":{"title":"WG's Lakeside","subtitle":"只是想显点粗浅技艺，那是我的初衷","description":null,"author":"Ticat","url":"onegoon.store","root":"/"},"pages":[],"posts":[{"title":" 网络篇","slug":"网络篇","date":"2020-03-09T07:38:51.000Z","updated":"2020-03-11T16:06:15.123Z","comments":true,"path":"2020/03/09/网络篇/","link":"","permalink":"onegoon.store/2020/03/09/网络篇/","excerpt":"","text":"Q: 两台服务器A和B的网络配置， A B IP address 192.168.26.129 192.168.26.3 Subnet mask 255.255.255.0 255.255.255.224 Default gateway 192.168.26.2 192.168.26.2 子网掩码本都为255.255.255.0， B的子网掩码不小心配成了255.255.255.224。它们还能正常通信吗？ 如果看到这个问题能自信回答。下文无须再看。 名词理解IPip地址 不要被地址前的ip吓到，ip地址也是地址，位置的标识。 比如在没有地图导航的年代，我们第一次去外国拜访某位好友，手里的只有地址 韩国庆尚南道金海市金宽路1 ~ 66号路3-14乙(内东郑德艺术第101号) 单看这个地址有点懵，我只知道韩国在哪。 ip的设计大抵也是如此 先来感受一下 IPv4地址 192.168.18.4 账面上分析：由3个点分为4组，可以是16进制也可以是10进制，32位 IPv6地址 2020:8210:242a:f270:1ca2:3f7:6ff:18af 账面上分析：由7个冒号分为8块也叫字段，16进制表示，128位 在IPv6中地址长度是128位，是IPv4的四倍。 1.在一个块中前导的零不必书写 2.全零的块可以省略，用符号::代替，为了避免歧义，一个IPv6地址中::只能用一次。 在某些情况下（例如表示一个包含地址的URL时），IPv6地址中的冒号分隔符可能与其他分隔符混淆，例如IP地址和端口号之间使用的冒号。这时候用[和]包围IPv6地址。例如，URL ​ http://[2001:0db8:85a3:08d3:1319:8a2e:0370:7344]:443/ 是指IPv6主机2001:0db8:85a3:08d3:1319:8a2e:0370:7344中的端口号443使用HTTP 、TCP和IPv6协议 增加的这些灵活性随之而来的就是会造成不必要的混淆性，同一个IP地址有多种的表示方式。 为了弥补这种情况，还要兼容特性，制定了规则，保证IP地址表示的唯一性 前导的零必须压缩。 符号::只能用于影响最大的地方（压缩最多的零），如果多少块中包含等长度的零，顺序靠前的块被替换为::。 a到f的十六进制数字应该用小写表示。 互联网上的每个接口必须有一个唯一的 I n t e r n e t 地址,也称作 I P 地址 IP地址的历史演变最初定义 Internet地址结构 = 网络号 + 主机号 网络号： 用于识别接口使用的IP地址在哪个网络中可被发现； 主机号：用于识别由网络部分给出的网络中的特定主机； 当时，大多数主机只有一个网络接口，因此术语接口地址和主机地址有时交替使用。 分类寻址 column 避免歧义，论证我的观点 IP地址分为A、B、C、D、E五类这是没有争议的。 但是我对E的前缀码有所怀疑 下表来自Wikipedia https://zh.wikipedia.org/wiki/IP%E5%9C%B0%E5%9D%80 A类IPv4地址 B类IPv4地址 C类IPv4地址 D类IPv4地址 E类IPv4地址 网络标志位 0 10 110 1110 11110 IP地址范围 1.0.0.0~127.255.255.255 128.0.0.0~191.255.255.255 192.0.0.0~223.255.255.255 224.0.0.0~239.255.255.255 240.0.0.0~247.255.255.255 可用IP地址范围 1.0.0.1~127.255.255.254 128.0.0.1~191.255.255.254 192.0.0.1~223.255.255.254 是否可以分配给主机使用 是 是 是 否 否 网络数量（个） 126 (27-2) 16384 (214) 2097152 (221) — — 每个网络中可容纳主机数（个） 16777214 (224-2) 65534 (216-2) 254 (28-2) — — 适用范围 大量主机的大型网络 中等规模主机数的网络 小型局域网 留给Internet体系结构委员会(IAB)使用【组播地址】 保留，仅作为搜索、Internet的实验和开发用 下图信息来自《TCP/IP详解 卷1：协议》译者: 范建华等 以上两处信息表达一致。但是我得疑问是如果E的前缀码是11110 那么剩下的那个区间的地址算什么 11111000 00000000 00000000 00000000 ~ 11111111 11111111 11111111 11111111 248.0.0.0 ~255.255.255.255 又查阅了《TCP/IP详解 卷1：协议》第二版，吴英等译 吴功宜 审校 E类的 地址范围 240.0.0.0 ~ 255.255.255.255 高位序 1111 我还是倾向于后者,所以之后的理论基于此，尽管这无关紧要。 现实中的不同网络可能有不同数量的主机，每台主机都需要一个唯一IP地址。 地址空间的划分涉及五大类，每类都基于网络中可容纳的主机数量，确定在一个32位的IPv地址中分配给网络号和主机号的位数。 由上图的信息可以算得下表数据 类 地址范围 高序位 用途 百分比 网络数 主机数 A 0.0.0.0~127.255.255.255 0 单播/特殊 1/2 128 (2^7) 16777216 (2^24) B 128.0.0.0~191.255.255.255 10 单播/特殊 1/4 16384 (2^14) 65536 (2^16) C 192.0.0.0~223.255.255.255 110 单播/特殊 1/8 2097152 (2^21) 256 (2^8) D 224.0.0.0~239.255.255.255 1110 组播 1/16 N/A N/A E 240.0.0.0~255.255.255.255 1111 保留 1/16 N/A N/A 百分比的计算可以 画棵哈夫曼树， 比如 0为左子树1为右子树 各类的网络数呈几何倍的递增，而网络数却呈几何倍递减，这样的分类有些脱离现实过于数字化了。 A类和B类网络号通常浪费太多主机号，而C类网络号则不能为很多站点提供足够的主机号。 比如C类网络号主机过少，而B类网络号主机又过多，如果想选择一个千为单位的网络号则十分尴尬了。 子网寻址背负历史包袱，负重前行 为了在不改变Internet核心路由基础设施的情况下解决这个问题，人们很自然想到一种方式，在一个站点接入Internet后为其分配一个网络号，然后又站点管理员进一步划分本地的子网数。 实现这个想法需要改变IP地址的网路部分和主机部分的限制，但这样做只是针对一个站点自身而言；Internet其余部分将只能’看到‘传统的A类、B类和C类部分。支持此功能的方法称为子网寻址。 解释一下，一个站点可能申请到了B类网络号，也就是IP地址的前16位确定了，余下16位自由位， 如果按照传统思维（分类寻址）那么剩下的16位就是主机号， 而按照子网寻址的逻辑，这16位对于Internet其他部分看来依然是主机号，对于站点自身来看，可通过子网掩码自由再划分成网络号与主机号。如下图一种可能的格式 这个例子中为一个B类地址被划分子网。它使用8位作为子网ID，提供256个子网和每个子网中254台主机（当前每个子网的第一个和最后一个地址无效，即从整个分配范围中去除第一个和最后一个地址）。这种划分可由网络管理员改变 前16位有权威机构分配。该站点的每个地址前16位固定不变，后16位由管理员分配。 注意只有划分子网的网络中的主机和路由器知道子网结构，在进行子网寻址前，Internet其他部分仍将它作为站点相关地址来看待。 下图展示如何工作 某个站点被分配一个典型的B类网络号128.32 。 网络管理员决定用于站点范围内的子网掩码为255.255.255.0,提供256个子网，每个子网可容纳256-2 = 254台主机。同一子网中每台主机的IPv4地址拥有相同子网号。左侧的局域网段中主机的IPv4地址开始于128.32.1，右侧的所有主机开始于128.32.2 。 Internet中其他站点要访问这个站点目的地址以128.32开始的所有流量直接由Internet路由系统交给边界路由器，如137.64.23.30要访问128.32.1.1 则先访问到站点边界路由器，边界路由器区分128.32网络中的不同子网。比如图中，它则要区分目的地址为128.32.1.x和目的地址为128.32.2.x的流量。这些地址分别表示子网号1和2，它们都采用128.32的B类网络号。那么路由器如何在地址中找到子网ID，这就需要子网掩码了。 子网掩码子网掩码是由一台主机或路由器使用的分配位，以确定如何从一台主机对应IP地址中获得网络和子网信息。IP子网掩码与对应的IP地址长度相同（IPv4为32位，IPv6为128位）。它们通常在一台主机或路由器中以IP地址相同的方式配置，既可以是静态的（通常是路由器），也可以是动态的（例如动态主机配置协议DHCP）。 子网掩码表示网络号与主机号的边界，全是1的那边表示网络号全是0的表示主机号 如IPv4地址为128.32.1.14/255.255.255.0 地址（128.32.1.14） 10000000 00100000 00000001 00001110 掩码（255.255.255.0） 11111111 11111111 11111111 00000000 按位与结果 （128.32.1.0） 10000000 00100000 00000001 00000000 （网络号和地址）按位异或结果 00000000 00000000 00000000 00001110 网络号为 128.32.1.0 子网主机ID为 14 可变长度子网掩码VLSM同一站点的不同部分，可将不同长度的子网掩码应用于相同网络号 CIDR和聚合20世纪90年代初，采用子网寻址缓解增长带来的痛苦后，Internet开始面临更严重的规模问题。有三个问题尤为重要。 到1994年，一半以上的B类地址已被分配。预计B类地址空间大约在1995年将被用尽。 32位的IPv4地址被认为不足以应付Internet在21世纪的初期规模。 全球性路由表的条目数（每个网络数对应一条），1995年大约为65000个条目，目前仍在增长。伴随着越来越多的ABC类路由条目出现，路由性能受到影响。 前缀聚合Private IPv4 addressesThe Internet Engineering Task Force (IETF) has directed the Internet Assigned Numbers Authority (IANA) to reserve the following IPv4 address ranges for private networks RFC1918 name IP address range Number of addresses Largest CIDR block (subnet mask) Host ID size Mask bits Classful description[Note 1] 24-bit block 10.0.0.0 – 10.255.255.255 16777216 10.0.0.0/8 (255.0.0.0) 24 bits 8 bits single class A network 20-bit block 172.16.0.0 – 172.31.255.255 1048576 172.16.0.0/12 (255.240.0.0) 20 bits 12 bits 16 contiguous class B networks 16-bit block 192.168.0.0 – 192.168.255.255 65536 192.168.0.0/16 (255.255.0.0) 16 bits 16 bits 256 contiguous class C networks 简化后如下图 只要兼容分类寻址，最大主机数就已经固定了（第一个和最后一个无效，有特殊用处） IP地址结构 大多数IPv4地址块最终被细分为一个地址用于识别连接Internet或者某些专用的内联网的计算机网络接口，这些地址称为单播地址。除了单播地址，其他类型的地址包括广播、组播和任播地址，它们可能涉及多个接口，还有一些特殊用途的地址。而我们主要围绕讨论的是单播地址 IP地址的种类 前缀码** 地址空间划分 无类型域间选路（CIDR） 广播地址 ，如果发送这个地址，所有10.11.12 网络里面的设备都可以收到 网络号， 子网掩码和IP按位与就可得到网络号 IP地址的主机号 ​ 全0：表示整个子网 ​ 全1：表示向子网上所有设备发送包，即“广播” IP怎么来的如何配置IP地址？ 往往我们上网不会为了IP而担忧，打开wifi，IP就自动设置好了。 其实就是使用默认的DHCP ##### 第一个协议 DHCP(Dynamic Host Configuration Protocol) 动态主机配置协议， 一个自动配置的协议有了这个协议，网络管理员就轻松多了。他只需要配置一段共享的 IP 地址。每一台新接入的机器都通过 DHCP 协议，来这个共享的 IP 地址里申请，然后自动配置好就可以了。等人走了，或者用完了，还回去，这样其他的机器也能用 DHCP 的方式就相当于租房。你不用装修，都是帮你配置好的。你暂时用一下，用完退租就可以了 #####解析 DHCP 的工作方式 1.DHCP Discover 新来的机器使用 IP 地址 0.0.0.0 发送了一个广播包，目的 IP 地址为 255.255.255.255。广播包封装了 UDP，UDP 封装了 BOOTP。其实 DHCP 是 BOOTP 的增强版 Boot request 我的 MAC 地址是这个，我还没有 IP，谁能给租给我个 IP 地址！ DHCP Offer ip DHCP Request ip ACK Socket库提供查询IP地址的功能 询问 DNS 服务器 获取IP ，端口号 Socket 存有 描述符，IP，端口号 通过“描述符”来识别socket 还没有MAC地址 ARP 通过IP找MAC 同网段广播 套接字的实体就是通信控制信息 协议栈是根据套接字中记录的控制信息来工作的。 连接是什么意思 连接实际上是通信双方交换控制信息 收据收发 数据小 首先，协议栈并不关心应用程序传来的数据是什么内容。应用程序在 调用 write 时会指定发送数据的长度，在协议栈看来，要发送的数据就是 一定长度的二进制字节序列而已。 其次，协议栈并不是一收到数据就马上发送出去，而是会将数据存放在内部的发送缓冲区中，并等待应用程序的下一段数据。这样做是有道理的。应用程序交给协议栈发送的数据长度是由应用程序本身来决定的，不同的应用程序在实现上有所不同，有些程序会一次性传递所有的数据，有些程序则会逐字节或者逐行传递数据。总之，一次将多少数据交给协议栈是由应用程序自行决定的，协议栈并不能控制这一行为。在这样的情况下，如果一收到数据就马上发送出去，就可能会发送大量的小包，导致网络效率下降，因此需要在数据积累到一定量时再发送出去。至于要积累多少数据才能发送，不同种类和版本的操作系统会有所不同，不能一概而论，但都是根据下面几个要素来判断的。 第一个判断要素是每个网络包能容纳的数据长度，协议栈会根据一个 叫作MTU的参数来进行判断。MTU 表示一个网络包的最大长度，在以太网中一般是 1500 字节。MTU 是包含头部的总长度，因此需要从MTU 减去头部的长度，然后得到的长度就是一个网络包中所能容纳的最大数据长度，这一长度叫作 MSS。当从应用程序收到的数据长度超过或者接近 MSS 时再发送出去，就可以避免发送大量小包的问题了。 另一个判断要素是时间。当应用程序发送数据的频率不高的时候，如果每次都等到长度接近 MSS 时再发送，可能会因为等待时间太长而造成发送延迟，这种情况下，即便缓冲区中的数据长度没有达到 MSS，也应该果 断发送出去。为此，协议栈的内部有一个计时器，当经过一定时间之后，就会把网络包发送出去 A。 判断要素就是这两个，但它们其实是互相矛盾的。如果长度优先，那么网络的效率会提高，但可能会因为等待填满缓冲区而产生延迟;相反地，如果时间优先，那么延迟时间会变少，但又会降低网络的效率。因此，在进行发送操作时需要综合考虑这两个要素以达到平衡。不过，TCP 协议规 格中并没有告诉我们怎样才能平衡，因此实际如何判断是由协议栈的开发者来决定的，也正是由于这个原因，不同种类和版本的操作系统在相关操 作上也就存在差异。 正如前面所说，如果仅靠协议栈来判断发送的时机可能会带来一些问 题，因此协议栈也给应用程序保留了控制发送时机的余地。应用程序在发送数据时可以指定一些选项，比如如果指定“不等待填满缓冲区直接发送”，则协议栈就会按照要求直接发送数据。像浏览器这种会话型的应用程 序在向服务器发送数据时，等待填满缓冲区导致延迟会产生很大影响，因 此一般会使用直接发送的选项。 MTU:Maximum Transmission Unit:一个网络包的最大长度，以太网中一般为1500字节。 MSS:Maximum Segment Size:除去头部之后，一个网络包所能容纳的TCP数据的最大长度。 最大分段大小。 TCP 和 IP 的头部加起来一般是 40 字节，因此 MTU 减去这个长度就是 MSS。例如，在以太网中， MTU 为 1500，因此 MSS 就是 1460。TCP/IP 可以使用一些可选参数 (protocol option)，如加密等，这时头部的长度会增加，那么 MSS 就会随着头部长度增加而相应缩短。 数据大 滑动窗口 所谓滑动窗口，就是在发送一 个包之后，不等待 ACK 号返回，而是直接发送后续的一系列包。 TCP整体流程 UDP 作为iOS出身，深受那一代人影响。所以第一个抓包工具使用的是Charles 俗称青花瓷，有免费版本，不过会定时的弹框。受限于中间人抓包法，注定无法捕获全部的包。 抓包神器 Wireshark参考资料 https://en.wikipedia.org/wiki/Private_network","categories":[],"tags":[{"name":"Internet, http","slug":"Internet-http","permalink":"onegoon.store/tags/Internet-http/"}]},{"title":"Swift Packages","slug":"Swift-Packages","date":"2020-03-08T14:29:13.000Z","updated":"2020-03-08T14:35:28.317Z","comments":true,"path":"2020/03/08/Swift-Packages/","link":"","permalink":"onegoon.store/2020/03/08/Swift-Packages/","excerpt":"","text":"苹果官方的包管理工具","categories":[],"tags":[{"name":"swift","slug":"swift","permalink":"onegoon.store/tags/swift/"}]},{"title":"cocoapods","slug":"cocoapods","date":"2020-03-08T14:09:05.000Z","updated":"2020-03-08T16:07:03.870Z","comments":true,"path":"2020/03/08/cocoapods/","link":"","permalink":"onegoon.store/2020/03/08/cocoapods/","excerpt":"","text":"What is CocoaPodsCocoaPods manages library dependencies for your Xcode projects. The dependencies for your projects are specified in a single text file called a Podfile. CocoaPods will resolve dependencies between libraries, fetch the resulting source code, then link it together in an Xcode workspace to build your project. Ultimately the goal is to improve discoverability of, and engagement in, third party open-source libraries by creating a more centralised ecosystem. iOS 开发的依赖管理工具 cocoapods 的作用 Project GoalsCocoaPods aims to improve the engagement with, and discoverability of, third party open-source Cocoa libraries. These project goals influence and drive the design of CocoaPods: Create and share libraries, and use them in your own projects, without creating extra work for library authors. Integrate non-CocoaPods libraries and hack on your own fork of any CocoaPods library with a simple transparent Podspec standard. Allow library authors to structure their libraries however they like. Save time for library authors by automating a lot of Xcode work not related to their libraries’ functionality. Support any source management system. (Currently supported are git, svn, mercurial, bazaar, and various types of archives downloaded over HTTP.) Promote a culture of distributed collaboration on pods, but also provide features only possible with a centralised solution to foster a community. Build tools on top of the core Cocoa development system, including those typically deployed to other operating systems, such as web-services. Provide opinionated and automated integration, but make it completely optional. You may manually integrate your CocoaPods dependencies into your Xcode project as you see fit, with or without a workspace. Solve everyday problems for Cocoa and Xcode developers. 解决的痛点 自动集成，便于管理，解决了手动集成的弊端，如代码更新难以维护 依赖相互依赖递归依赖 各个库依赖的版本不同问题 查看细节 –verbose1234pod install --verbose# 不更新本地库 比如本地缓存有AFN2.0就不会自动更新到3.0# [-v | --verbose]pod install --verbose --no-repo-update Podfile.lock （记录install的文件，不只是pod install）这是 CocoaPods 创建的最重要的文件之一。它记录了需要被安装的 pod 的每个已安装的版本。如果你想知道已安装的 pod 是哪个版本，可以查看这个文件。推荐将 Podfile.lock 文件加入到版本控制中，这有助于整个团队的一致性。 第一次pod install会创建.lock文件，之后pod install（如果Podfile没改变）则不会改动.lock文件 而执行pod update 则会强行按照Podfile文件进行拉取依赖文件，并更新.lock文件。这样看来如果执行update指令还是有风险的 Manifest.lock （为了校验Pods里的文件与Podfile.lock记录是否一致）这是每次运行 pod install 命令时创建的 Podfile.lock 文件的副本。如果你遇见过这样的错误 沙盒文件与 Podfile.lock 文件不同步 (The sandbox is not in sync with the Podfile.lock)，这是因为 Manifest.lock 文件和 Podfile.lock 文件不一致所引起。由于 Pods 所在的目录并不总在版本控制之下，这样可以保证开发者运行 app 之前都能更新他们的 pods，否则 app 可能会 crash，或者在一些不太明显的地方编译失败。 日常工作中是否应把pod相关文件加到版本控制中Pods文件夹不要加 Podfile 要加 Podfile.lock 要加到版本控制中 假设我们在 Podfile 中写上: pod &#39;AFNetWorking&#39;，那么默认是安装 AFNetworking 的最新代码。这就导致用户 A 可能装的是 3.0 版本，而用户 B 再安装就变成了 4.0 版本。即使我们在 Podfile 中指定了库的具体版本，那也不能保证不出问题。因为一个第三方库还有可能依赖其他的第三方库，而且不保证它的依赖关系是具体到版本号的。 因此 Podfile.lock 存在的意义是将某一次 pod install 时使用的各个库的版本，以及这个库依赖的其他第三方库的版本记录下来，以供别人使用。 这样一来，pod install 的流程其实是: 判断 Podfile.lock 是否存在，如果不存在，按照 Podfile 中指定的版本安装 如果 Podfile.lock 存在，检查 Podfile 中每一个 Pod 在 Podfile.lock 中是否存在 如果存在， 则忽略 Podfile 中的配置，使用 Podfile.lock 中的配置(实际上就是什么都不做) 如果不存在，则使用 Podfile 中的配置，并写入 Podfile.lock 中 而另一个常用命令 pod update 并不是一个日常更新命令。它的原理是忽略 Podfile.lock 文件，完全使用 Podfile 中的配置，并且更新 Podfile.lock。一旦决定使用 pod update，就必须所有团队成员一起更新。因此在使用 update 前请务必了解其背后发生的事情和对团队造成的影响，并且确保有必要这么做。 参考cocoapods objccn.io 上的期刊《深入理解CocoaPods》 张星宇的博客","categories":[],"tags":[{"name":"CocoaPods","slug":"CocoaPods","permalink":"onegoon.store/tags/CocoaPods/"}]},{"title":"terminal经验 ","slug":"terminal经验","date":"2020-03-07T05:59:05.000Z","updated":"2020-03-07T07:21:21.586Z","comments":true,"path":"2020/03/07/terminal经验/","link":"","permalink":"onegoon.store/2020/03/07/terminal经验/","excerpt":"","text":"操作文件变更目录 (change directory)123456789# 跳转到上层路径 比如当前路径 ~/a/b -&gt; ~/acd .. # 跳转到上两层cd ...# （用户）当前用户的根目录 比如我的电脑用户名alan， /Users/alancd ~cd --# 跳转到上一次所在的路径cd - 创建文件1234# 创建文件夹mkdir# 创建文件touch 查看文件123456789101112# 查看文件内容cat # 查看当前路径pwd# 当前文件列表ls# ls /bin# 显示隐藏文件ls -a # 详细信息，主要可以看文件权限ls -l 复制文件12# 将a复制到bcp a b 删除文件123456# 删除空文件夹rmdir # 删除文件 -r递归删除rm -r &lt;filePath&gt;# 删除文件 -f强行删除rm -rf &lt;filePath&gt; 移动文件12# 移动文件 a -&gt; bmv a b 打开文件12# 国际通用helpopen --help 12# 打开文件（默认程序打开）open &lt;fileName&gt; 12# 使用特定app打开特定文件open -a &lt;appUrl&gt; &lt;fileName&gt; ​ 文件内查找123grep# 比如可以配合lsls | grep &lt;filter&gt;","categories":[],"tags":[{"name":"terminal","slug":"terminal","permalink":"onegoon.store/tags/terminal/"}]},{"title":"git经验","slug":"git经验","date":"2020-03-07T05:57:26.000Z","updated":"2020-03-07T10:37:18.472Z","comments":true,"path":"2020/03/07/git经验/","link":"","permalink":"onegoon.store/2020/03/07/git经验/","excerpt":"","text":"撤销git reset通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”。向上移动分支，原来指向的提交记录就跟重来没有提交过一样。 git revert两者的区别reset意义 ：回到指定节点（哈希值或者相对引用） 表象：清理结点，这个节点之后记录的统统不要了，真正做到回到过去。 revert意义：撤销指定结点的操作 表象：提交一新个记录，该次提交的作用为上一步的逆操作，工作树上表现为新增一个结点 总结得到的结果是一样的，但是在work tree 上表现不同， reset为不留痕迹 revert保留完整的操作记录","categories":[],"tags":[{"name":"git","slug":"git","permalink":"onegoon.store/tags/git/"}]},{"title":"Terminal command","slug":"Terminal-command","date":"2020-03-05T10:34:08.000Z","updated":"2020-03-05T10:47:31.954Z","comments":true,"path":"2020/03/05/Terminal-command/","link":"","permalink":"onegoon.store/2020/03/05/Terminal-command/","excerpt":"","text":"iOS 13 以来， 手机内存吃紧，UI上显示还空余5个多G，可是Xcode上却显示只剩下一个多G，该信谁的 开发也有过一些难以想象的苹果的bug，Xcode编译程序导致访问 nib 文件必现crash 最近又发现 Mac (Mojave 10.14.6) 上的文件系统，更新文件增加文件当前Finder界面并不会立刻更新，而是需要来回切换才会显示，有时即使这样也不会显示新增的文件。 不得不使用命令来操作文件了 也有可能是我的15年的老古董支撑不起强大的操作系统了 作为程序员，本不应该依赖UI界面的，正好借此开始逐渐脱离图形界面操作 希望这些只是苹果在创新尝试的小纰漏，也希望苹果能有更多的进步创新。","categories":[],"tags":[]},{"title":"Django Restful","slug":"Django-Restful","date":"2020-03-04T03:35:33.000Z","updated":"2020-03-04T07:46:05.445Z","comments":true,"path":"2020/03/04/Django-Restful/","link":"","permalink":"onegoon.store/2020/03/04/Django-Restful/","excerpt":"","text":"python 搭建rest API有两大主流 Django 与 Flask Django 较重 组件齐全 Flask 较轻，灵活 我选择先入手Django，原因是生态。 后续有能力还会在来Flask RESTRepresentational state transfer 表现层状态转换 Roy Thomas Fielding博士提出的一种网络服务架构的风格。也叫restful。 表现层状态转换是基于超文本传输协议之上的一族约束和属性，是一种设计网络服务的软件构建风格。 客户端发出请求以统一资源标识符访问和操作网络资源 当前在三种主流的Web服务实现方案中，因为REST模式与复杂的SOAP和XML-RPC相比更加简洁，越来越多的Web服务开始采用REST风格设计和实现。 Django rest 框架 django-rest-framework 官方文档 https://www.django-rest-framework.org/","categories":[],"tags":[]},{"title":"SQL","slug":"SQL","date":"2020-03-03T10:35:43.000Z","updated":"2020-03-03T14:25:37.665Z","comments":true,"path":"2020/03/03/SQL/","link":"","permalink":"onegoon.store/2020/03/03/SQL/","excerpt":"","text":"MYSQL安装 mysql下载：https://dev.mysql.com/downloads/ navicat下载：https://www.navicat.com.cn/ 出现个问题 .bash_profile 添加路径 但是在terminal上无效，还需要手动 设置PATH PATH=${PATH}:/usr/local/mysql/bin mysql -u root -p -u 代表user 这里用户名为root -p password 使用MYSQL的图形化程序navicat","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"onegoon.store/tags/SQL/"}]},{"title":"有一个想法","slug":"有一个想法","date":"2020-03-02T12:25:17.000Z","updated":"2020-03-02T14:30:22.560Z","comments":true,"path":"2020/03/02/有一个想法/","link":"","permalink":"onegoon.store/2020/03/02/有一个想法/","excerpt":"","text":"有一个想法。 想搭建一个平台，后端到前端产品到UI","categories":[],"tags":[{"name":"架构","slug":"架构","permalink":"onegoon.store/tags/架构/"}]},{"title":"Django入门","slug":"Django入门","date":"2020-02-28T02:39:28.000Z","updated":"2020-03-06T05:04:15.130Z","comments":true,"path":"2020/02/28/Django入门/","link":"","permalink":"onegoon.store/2020/02/28/Django入门/","excerpt":"","text":"Django 初级篇虚拟环境 virtualenv1virtualenv venv -p python3 为project提供独立的python环境。pycharm默认开启的 开启 1source venv/bin/activate 开启后 命令行最左端有(venv)字样 代表虚拟环境开启 1(venv) ➜ PlanA 注意开启后 所有操作都在venv环境下进行的 使用 python 而不是python3，pip而不是pip3 关闭 1deactivate 安装 Djangoinstall django ```12345678就此环境搭建完毕##### 开始构建项目（Project）我的第一个项目`PlanA````django-admin startproject PlanA 12345678910PlanA/ &lt;-- higher level folder├── PlanA &lt;-- django project folder （ `startproject` 命令创建的）│ ├── PlanA│ │ ├── __init__.py│ │ ├── asgi.py│ │ ├── settings.py│ │ ├── urls.py│ │ └── wsgi.py│ └── manage.py└── venv &lt;-- virtual environment folder 这些目录和文件的用处是：(django 文档给出) The outer mysite/ root directory is a container for your project. Its name doesn’t matter to Django; you can rename it to anything you like. manage.py: 一个让你用各种方式管理 Django 项目的命令行工具。你可以阅读 django-admin and manage.py 获取所有 manage.py 的细节。 里面一层的 mysite/ 目录包含你的项目，它是一个纯 Python 包。它的名字就是当你引用它内部任何东西时需要用到的 Python 包名。 (比如 mysite.urls). mysite/__init__.py：一个空文件，告诉 Python 这个目录应该被认为是一个 Python 包。如果你是 Python 初学者，阅读官方文档中的 更多关于包的知识。 mysite/settings.py：Django 项目的配置文件。如果你想知道这个文件是如何工作的，请查看 Django 配置 了解细节。 mysite/urls.py：Django 项目的 URL 声明，就像你网站的“目录”。阅读 URL调度器 文档来获取更多关于 URL 的内容。 mysite/asgi.py: An entry-point for ASGI-compatible web servers to serve your project. See How to deploy with ASGI for more details. mysite/wsgi.py：作为你的项目的运行在 WSGI 兼容的Web服务器上的入口。阅读 如何使用 WSGI 进行部署 了解更多细节。 一个project可以包含很多个app 同一个app可以存在与多个project中 创建appstartapp boards ```123456789101112注意这次我们用的是`startapp`.├── __init__.py├── admin.py├── apps.py├── migrations│ └── __init__.py├── models.py├── tests.py└── views.py PlanA/ &lt;– higher level folder├── boards &lt;– our new django app!│ ├── init.py│ ├── admin.py│ ├── apps.py│ ├── migrations│ │ └── init.py│ ├── models.py│ ├── tests.py│ └── views.py├── PlanA &lt;– django project folder （ startproject 命令创建的）│ ├── PlanA│ │ ├── init.py│ │ ├── asgi.py│ │ ├── settings.py│ │ ├── urls.py│ │ └── wsgi.py│ └── manage.py└── venv &lt;– virtual environment folder 123456##### 本地运行服务 8000端口``` python manage.py runserver 更换端口默认情况下，runserver 命令会将服务器设置为监听本机内部 IP 的 8000 端口。 如果你想更换服务器的监听端口，请使用命令行参数。举个例子，下面的命令会使服务器监听 8080 端口： 1$ python manage.py runserver 8080 如果你想要修改服务器监听的IP，在端口之前输入新的。比如，为了监听所有服务器的公开IP（这你运行 Vagrant 或想要向网络上的其它电脑展示你的成果时很有用），使用： 1$ python manage.py runserver 0:8000 0 是 0.0.0.0 的简写。完整的关于开发服务器的文档可以在 :djamdin:runserver 参考文档中找到。 新版django 的路由 path与re_path1234urlpatterns = [ path(&apos;polls/&apos;, include(&apos;polls.urls&apos;)), path(&apos;admin/&apos;, admin.site.urls),] 以前是url path() 参数： route¶route 是一个匹配 URL 的准则（类似正则表达式）。当 Django 响应一个请求时，它会从 urlpatterns 的第一项开始，按顺序依次匹配列表中的项，直到找到匹配的项。 这些准则不会匹配 GET 和 POST 参数或域名。例如，URLconf 在处理请求 https://www.example.com/myapp/ 时，它会尝试匹配 myapp/ 。处理请求 https://www.example.com/myapp/?page=3 时，也只会尝试匹配 myapp/。 path() 参数： view¶当 Django 找到了一个匹配的准则，就会调用这个特定的视图函数，并传入一个 HttpRequest 对象作为第一个参数，被“捕获”的参数以关键字参数的形式传入。稍后，我们会给出一个例子。 path() 参数： kwargs¶任意个关键字参数可以作为一个字典传递给目标视图函数。本教程中不会使用这一特性。 path() 参数： name¶为你的 URL 取名能使你在 Django 的任意地方唯一地引用它，尤其是在模板中。这个有用的特性允许你只改一个文件就能全局地修改某个 URL 模式。 当你了解了基本的请求和响应流程后，请阅读 教程的第 2 部分 开始使用数据库. 数据库迁移manage.py makemigrations```12```python manage.py migrate 资料https://tutorial.djangogirls.org/zh/ 一个gitbook，难度较低的教程，如果有基础不建议看 https://github.com/TwoWater/Python 国人写的教程，能够快速了解陌生的信息 https://docs.djangoproject.com/ 官方文档，更新较为即时，语言可选中文。 https://simpleisbetterthancomplex.com/series/beginners-guide/1.11/ 新人友善的博客，带你一步一步完成一个论坛类的project 17年写的有些东西需要更新。","categories":[],"tags":[{"name":"python, django","slug":"python-django","permalink":"onegoon.store/tags/python-django/"}]},{"title":"19年总结","slug":"19年总结","date":"2019-12-31T15:22:21.000Z","updated":"2019-12-31T15:24:47.970Z","comments":true,"path":"2019/12/31/19年总结/","link":"","permalink":"onegoon.store/2019/12/31/19年总结/","excerpt":"","text":"工作上技术长进学会了如何团队开发 iOS的技能点 点的比较多 ​ 单元测试写了不少，对单元测试有了另一番的理解感悟，code容易片面，test来补全 ​ Swift 较为精进毕竟日常开发，编译了Swift并阅读了部分源码，如网络部分，json解析，数据结构部分等 ​ Darwin-xnu, pthread, dyld, Foundation.混个面熟吧。 ​ 从头跟了MonkeyDev的逆向，会使用逆向工具，更加了解了iOS&amp;macOS的运行机制， ​ 对MachO的解析也实践了一段，配合阅读《程序员的自我修养》《深入理解计算系统》。 ​ 汇编，要想理解、验证一些底层的东西还是绕不开汇编的。但是Risc实在太精简了 数据结构与算法，多数的还处于思想上。能手写的只有那几个排序，，base huffman实现了一个解压缩算法 操作系统也学了些，了解CPU的一些机制流水线，多发射，超标量，分支预测，多核协作等。 网络 组内分享了一次TCP/IP，继续阅读POSIX的源码，目前仅完成了用户态 socket的demo，其实还是在应用层。后续要深入到内核态看看。 Wireshark真是个好东西，大家能看到的才有说服力。 生活上程序员离开了电脑如丧失了大脑，编码之外的其他人情世故似乎不差了不少。（也仅可能是我吧，个人感受）。 跑了不少次医院，对医院的流程，对世故的处理有所感悟 篮球，年龄将长，身体越发虚弱~~··。适当锻炼，身体倍棒，远离CS 马上要见家长了，紧张","categories":[],"tags":[]},{"title":"mac socket","slug":"mac-socket","date":"2019-12-27T08:14:01.000Z","updated":"2019-12-29T15:06:49.204Z","comments":true,"path":"2019/12/27/mac-socket/","link":"","permalink":"onegoon.store/2019/12/27/mac-socket/","excerpt":"","text":"### 套接字接口的起源 套接字接口是加州大学伯克利分校的研究员在20世纪80年代早期提出来的。因为这个原因，它也常被叫做伯克利套接字。伯克利的研究者使得套接字接口适用于任何底层的协议。第一个实现的就是针对TCP/IP协议的，他们把它包括在Unix 4.2BSD的内核里，并且分发给许多学校和实验室。这在因特网的历史上是一个重大事件。几乎一夜之间，成千上万的人们接触到了TCP/IP和它的源代码。它引起了巨大的轰动，并激发了新的网络和网络互联研究的浪潮 节选自 《深入理解计算机系统》第三版 伯克利 Berkeley Core Foundation通过CFNetwork提供了封装套接字的CFSocket和CFStream，此外还进一步提供了一些协议的封装，例如CFFTP、CFHTTP等 BSD套接字是XNU中所有网络组件的核心 socket 函数客户端和服务器使用socket函数来创建一个套接字描述符 在&lt;sys/socket.h&gt;中定义int socket(int, int, int); 在bsd&gt;kern&gt;syscalls.master 中97 AUE_SOCKET ALL { int socket(int domain, int type, int protocol); } 若成功则为非负描述符，若出错则为-1 12345678910/** domain 套接字域（地址/协议族）通常指的是 AF（Address Family）或者PF(Protocol Family)表示第2层或第3层地址对应的套接字地址模式。常见的IP协议，即PF_INET或AF_INET传统上使用的是AF_*常量，PF_*常量只不过是通过AF_*常量#define得到的* type * protocol 所在文件bsd &gt; netinet &gt; in.h Xcode里面也能看见注释*/int socket(int domain, int type, int protocol) 1234567891011// socket.h 114~123/* * Types */#define SOCK_STREAM 1 /* stream socket */#define SOCK_DGRAM 2 /* datagram socket */#define SOCK_RAW 3 /* raw-protocol interface */#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)#define SOCK_RDM 4 /* reliably-delivered message */#endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */#define SOCK_SEQPACKET 5 /* sequenced packet stream */ 123456789101112131415// socket.h 528~586/* * Address families. */#define AF_UNSPEC 0 /* unspecified */#define AF_UNIX 1 /* local to host (pipes) */#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)#define AF_LOCAL AF_UNIX /* backward compatibility */#endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */#define AF_INET 2 /* internetwork: UDP, TCP, etc. */...#define AF_INET6 30 /* IPv6 */... 1234567891011// socket.h 632~680/* * Protocol families, same as address families for now. */#define PF_UNSPEC AF_UNSPEC#define PF_LOCAL AF_LOCAL#define PF_UNIX PF_LOCAL /* backward compatibility */#define PF_INET AF_INET...#define PF_INET6 AF_INET6...","categories":[],"tags":[{"name":"socket","slug":"socket","permalink":"onegoon.store/tags/socket/"}]},{"title":"Mac app socket server","slug":"Mac-app-socket-server","date":"2019-12-26T08:24:57.000Z","updated":"2019-12-27T01:24:50.949Z","comments":true,"path":"2019/12/26/Mac-app-socket-server/","link":"","permalink":"onegoon.store/2019/12/26/Mac-app-socket-server/","excerpt":"在macOS app 上创建socket server 发现创建失败 抛出异常代码如下 1try checkNotMinus1&#123; Darwin.bind(ipv4Socket, addrPtr, UInt32(MemoryLayout&lt;sockaddr_in&gt;.size)) 123456789/// 封装检测是否为-1/// errno 为Darwin的错误码enum SocketError: Error &#123; case socketCreateFailed(Int32) &#125;@discardableResultfunc checkNotMinus1(_ f: () -&gt; Int32) throws -&gt; Int32 &#123; let r = f() guard r != -1 else &#123; throw SocketError.socketCreateFailed(errno) &#125; return r&#125; catch中的error 为ssocketCreateFailed(1) 也就是errno为1","text":"在macOS app 上创建socket server 发现创建失败 抛出异常代码如下 1try checkNotMinus1&#123; Darwin.bind(ipv4Socket, addrPtr, UInt32(MemoryLayout&lt;sockaddr_in&gt;.size)) 123456789/// 封装检测是否为-1/// errno 为Darwin的错误码enum SocketError: Error &#123; case socketCreateFailed(Int32) &#125;@discardableResultfunc checkNotMinus1(_ f: () -&gt; Int32) throws -&gt; Int32 &#123; let r = f() guard r != -1 else &#123; throw SocketError.socketCreateFailed(errno) &#125; return r&#125; catch中的error 为ssocketCreateFailed(1) 也就是errno为1 ⌘左键 进入代码定义（Jump to Definition） 发现只有定义没有注释，能看到他是定义在Darwin中 打开Darwin-xnu 找到errno.h (&lt;sys/errno.h&gt;) 发现错误码为1 对应 Operation not permitted 我是使用Xcode的版本 Version 11.2.1 (11B500) 新版Xcode会把app 的能力单独一页列出来 当我勾选Network 的 Server选项后 bind成功了","categories":[],"tags":[{"name":"Mac OS","slug":"Mac-OS","permalink":"onegoon.store/tags/Mac-OS/"}]},{"title":"SF Symbols","slug":"SF-Symbols","date":"2019-12-26T05:06:06.000Z","updated":"2019-12-26T05:56:36.424Z","comments":true,"path":"2019/12/26/SF-Symbols/","link":"","permalink":"onegoon.store/2019/12/26/SF-Symbols/","excerpt":"SF Symbols Mac上的一款app 有超1500个符号可供使用，也可以自定义符号 可以导出文件，用sketch编辑","text":"SF Symbols Mac上的一款app 有超1500个符号可供使用，也可以自定义符号 可以导出文件，用sketch编辑 UIKit 提供了两种API，一种是使用系统符号，另外一种是自定义 init(systemName:) init(systemName:compatibleWith:) init(systemName:withConfiguration:)methods of UIImage. init(named:) init(named:in:compatibleWith:) init(named:in:with:) 1let image = UIImage(systemName: \"square.and.arrow.up\") image 会加载对应的符号 也可以自定义符号 Assets.xcassets / + / New Symbol Image Set / 拖拽编辑好的SVG文件到xcode中 效果如图 1let image = UIImage(systemName: \"arrowupfill\") #####link refer Creating Custom Symbol Images for Your App","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"onegoon.store/tags/iOS/"}]},{"title":"iOS URLSession Request","slug":"iOS-URLSession-Request","date":"2019-11-27T15:14:13.000Z","updated":"2019-11-27T16:22:22.736Z","comments":true,"path":"2019/11/27/iOS-URLSession-Request/","link":"","permalink":"onegoon.store/2019/11/27/iOS-URLSession-Request/","excerpt":"概览","text":"概览 参考资料 Foundation","categories":[],"tags":[]},{"title":"抓包","slug":"抓包","date":"2019-10-01T07:25:18.000Z","updated":"2019-12-26T09:18:01.212Z","comments":true,"path":"2019/10/01/抓包/","link":"","permalink":"onegoon.store/2019/10/01/抓包/","excerpt":"网络已成为当下人类的必需品，身为开发人员势必了解其原理，无论是正向开发，抑或是逆向攻击。 网络抓包，是对网络传输中的数据包进行抓取。而后可对其进行分析。 正向开发中，我们可以通过抓包进行验证发送的数据是否正确，如验证发送的次数，host，path，header等。 也可以对特定的请求模拟给出特定的响应结果，检查发送端在得到响应后的行为是否符合预期，比如验证一些业务场景极少发生的场景以及边界等。","text":"网络已成为当下人类的必需品，身为开发人员势必了解其原理，无论是正向开发，抑或是逆向攻击。 网络抓包，是对网络传输中的数据包进行抓取。而后可对其进行分析。 正向开发中，我们可以通过抓包进行验证发送的数据是否正确，如验证发送的次数，host，path，header等。 也可以对特定的请求模拟给出特定的响应结果，检查发送端在得到响应后的行为是否符合预期，比如验证一些业务场景极少发生的场景以及边界等。 抓包工具Charles (青花瓷/花瓶)Charles 支持截取 HTTP/HTTPS Charles 抓包原理是将自己设为代理。 代理相当于一个中间人 ​ 客户端发送的所有数据都会先通过代理，然后由代理发送给服务器。 ​ 服务器收到请求后，将相应消息返回给代理，然后由代理发送给客户端。 对客户端来说代理就是服务器，对服务器来说代理就是客户端，所以两者都不会感知网络被拦截了。这就是中间人攻击的原理。 拦截iPhone上的网络请求 将Charles的代理功能打开 设置代理并勾选”Enable transparent HTTP proxying” 查看ip， Help -&gt; Local IP Address . 或者去网络设置中去查看，如今可以看到两种地址，短的是IPv4,长的是IPv6. 在iphone上，设置网络代理为Charles启动的代理服务器。","categories":[],"tags":[{"name":"http","slug":"http","permalink":"onegoon.store/tags/http/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-05-28T14:39:18.000Z","updated":"2019-05-28T14:39:18.000Z","comments":true,"path":"2019/05/28/hello-world/","link":"","permalink":"onegoon.store/2019/05/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}