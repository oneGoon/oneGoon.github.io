{"meta":{"title":"WG's Lakeside","subtitle":"只是想显点粗浅技艺，那是我的初衷","description":null,"author":"Ticat","url":"onegoon.store","root":"/"},"pages":[],"posts":[{"title":"lldb","slug":"lldb","date":"2020-03-20T01:53:17.000Z","updated":"2020-03-20T02:20:56.170Z","comments":true,"path":"2020/03/20/lldb/","link":"","permalink":"onegoon.store/2020/03/20/lldb/","excerpt":"","text":"单指令si ni n","categories":[],"tags":[{"name":"lldb","slug":"lldb","permalink":"onegoon.store/tags/lldb/"}]},{"title":"汇编篇","slug":"汇编篇","date":"2020-03-19T11:07:54.000Z","updated":"2020-03-20T08:37:46.245Z","comments":true,"path":"2020/03/19/汇编篇/","link":"","permalink":"onegoon.store/2020/03/19/汇编篇/","excerpt":"","text":"80x86指令系统指令格式[标号：] 操作码[操作数,...] [;注释] 整数指令 浮点数指令 操作系统行指令7类寻址 立即寻址 寄存器寻址 直接寻址 寄存器间接寻址 相对寄存器间接寻址 基址加变址寻址 相对基址加变址寻址 立即寻址把立即数送到寄存器中 123MOV BL, 56H ; 56H -&gt; BLMOV AX, 2056H ; 2056H -&gt; AXMOV ECX, 12345678H ; 12345678 -&gt; ECX 立即数只能作源操作数，不能作目的操作数。 寄存器寻址操作数在CPU的寄存器中，而寄存器的名由指令指出。 12INC CL;MOV AX, BX; (BX) -&gt; AX BX的内容给AX 直接寻址操作数有效地址直接包含在指令中，它位于操作码之后，存放在代码段中。如果指令无前缀指明在哪一段，则默认操作数存放在数据段。 1MOV AX, [2000H]; DS段2000H的内容送AL，2001H的内容送AH。 逻辑地址 = 段基址 + 偏移地址 []里面是偏移地址 段基址默认DS段 指定段加冒号 1MOV AX, ES: [2000H]; ES段2000H的内容送AL，2001H的内容送AH。 寄存器间接寻址操作数的偏移地址存放在寄存器中，而操作数存放在存储器中。 1234MOV AX, [BX]; AX &lt;- (DS*10H+(BX)) MOV AX, [BP]; AX &lt;- (SS*10H+(BP))MOV AX, ES: [BX]; AX &lt;- ()MOV AX, DS: [BP]; 白话：比如存储器中有个数a地址为0x12345678 寄存器BX中存放的就是0x12345678 执行结果是把存放在BX中的0x12345678传送给AX SS：堆栈段的段寄存器 相对寄存器间接寻址寄存器内容与位移量之和形成操作数的有效地址。即 EA = [寄存器]+位移量 12MOV ECX, 1500H[EAX]; DS段(EAX)+1500H中的双字数据送到ECX。MOV ECX, [EAX + 1500H]; 基址加变址寻址基址寄存器内容与变址寄存器内容之和形成操作数的偏移地址。即 EA = [基址寄存器] + [变址寄存器] 1234基址寄存器：任何一个32位通用寄存器变址寄存器：除ESP之外的任一个32位通用寄存器MOV AX, [EBX+ECX]; DS段(EBX)+(ECX)中的字数据送AXMOV AX, [EBX][ECX]; 相对基址加变址寻址EA == 有效地址 == 偏移地址 基址寄存器内容与变址寄存器内容再加偏移量之和形成操作数的有效地址。 EA = [基址寄存器]+[变址寄存器]+偏移量 1234MOV AX, 1234H[BX+DI];MOV AX, [BX+DI+1234H];MOV AX, 1234H[BX][DI];# 几种方式等效，DS段(BX)+(DI)+1234H 中的字数据送AX 与跳转有关的寻址方式无条件转移：JMP dst; dst:转移目标 调用语句： CALL dst; dst:调用目标 交换指令XCHG用于交换两个操作数 1XCHG OP1, OP2 注意可以是两个寄存器或者一个寄存器与一个存储器。但不能是两个存储器 I/O指令 IN 和 OUT用于在I/O端口和AL、AX或EAX累加器之间交换数据。 12IN OP1, OP2 OUT OP1, OP2 装入有效地址指令LEA1LEA OP1, OP2 将有效地址（偏移地址）送通用寄存器。 装入全地址指令LDS，LES，LFS，LGS，LSS12LDS reg, mem... 取mem指示的32位或48位全地址指针（即一个16位段选择符和一个16位或32位偏移地址）装入段寄存器和16位或32位reg中 比如段基址和偏移地址都是16位，段基址送段寄存器，偏移地址动reg中。 例如： 12X DD 12345678HLDS SI , X; DS =1234H, SI = 5678H 对于16位和32位保护方式，选择符送段寄存器，偏移地址送reg中 例如 12345X DD 12345678H; 32位偏移值DW 0010H; 16位选择符LDS ESI, X; ESI=12345678H,DS=0010H 压栈/弹栈指令PUSH/POP PUSH OP1 POP OP1 SS 堆栈段的第一个地址 SP 栈顶 全部通用寄存器压栈和出栈指令PUSHA/POPA: 16位通用寄存器压栈和出栈指令。 入栈顺序为：AX、CX、BX、DX、SP、BP、SI和DI。 PUSHAD/POPAD: 32位通用寄存器压栈和出栈指令 入栈顺序为：EAX、ECX、EBX、EDX、ESP、EBP、ESI和EDI。 其中：SP和ESP为操作前的栈顶指针。 查表转换指令XLAT1XLAT; AL &lt;- ((BX)+(AL)) BX的内容加上AL的内容 得出一个地址，那个地址指向的内容传送给AL 算术运算类与运算有关的标志 CF: 进位/借位标志。加、减运算最高位产生进位/借位时置1 AF: 辅助进位/借位标志。加、减运算时低半字节产生进位/借位是置1。 OF: 溢出标志。有符号二进制加、减运算结果超出范围时置1。（最高位，次高位只有一个有进位则溢出） ZF: 零标志。结果为零时置1。 SF: 符号标志。结果为负时置1。（最高位为1） PF: 奇偶标志。 结果”1“的个数为偶数时置1。 加法和减法指令ADD/SUB12ADD OP1, OP2; OP1 &lt;- OP1+OP2, 置标志位SUB OP1, OP2; OP1 &lt;- OP1-OP2，置标志位 例如：AL=64H，AH=0A8H,求执行下列指令的结果和标志位的状态。 （1）\u0010ADD AL. AH 123456789 0110 0100 // 100D 通过补码运算 0110 0100 +1010 1000 // -88D - 0101 10001 0000 1100 // 12D （高位1舍弃） 0000 1100 | OF | SF | ZF | AF | PF | CF || ---- | ---- | ---- | ---- | ---- | ---- || 0 | 0 | 0 | 0 | 1 | 1 | 1010 1000 最高位1为负数 求补码（取反加1）取反 0101 0111 -&gt; 加1 0101 1000 -&gt; -88D （2）SUB AL, AH; 123456789 1 0110 0100 // 100D 高位借1 0110 0100 -1010 1000 // -88D + 0101 1000 1011 1100 // -68D (188D) 1011 1100 //-68D 最高位为1负数，补码0100 0100 68D| OF | SF | ZF | AF | PF | CF || ---- | ---- | ---- | ---- | ---- | ---- || 1 | 1 | 0 | 1 | 0 | 1 | 带进位加法/减法指令 ADC/SBB123ADC OP1, OP2; OP1 &lt;- OP1 + OP2 + CFSBB OP1, OP2; OP1 &lt;- OP1 - OP2 - CF 比如实现128位数相加 可以拆分为64 64 利用进位标志 加1/减1指令 INC/DEC12INC OP1; OP1 &lt;- OP1 + 1DEC OP1; OP1 &lt;- OP1 - 1 交换加法指令XADD12XADD OP1, OP2; OP1 &lt;- OP1+OP2 ; OP2 &lt;- OP1 变反指令NEG1NEG OP1; OP1 &lt;- -OP1 置标志位 例子: 12345678NEG AL；若(AL) = 13H, 执行NEG指令后， (AL) = EDH13H =&gt; 0001 0011补码 =&gt; 1110 1101 =&gt; EDH所以AL的内容为EDH 1110 1101 ED 比较指令CMP将OP1减去OP2，但结果不存在OP1中，只使结果影响标志位。 1CMP OP1, OP2; OP1 - OP2, 置标志位 A - B CF ZF SF OF A = B - 1 - - 无符号数（看CF） A &lt; B 1 0 - - A &gt; B 0 0 - - 有符号数 A &lt; B - 0 1 0 A &gt; B - 0 0 0 无符号乘法指令MUL1MUL OP1 被乘数隐含在累加器中（AL,AX,EAX）,OP1为乘数。字节运算时乘积返回到AX；字运算乘积返回到DX：AX； 双字运算时乘积返回到EDX：EAX。 影响标志位OF和CF： 若积的高字节、字或双字为0，则OF、CF清0.否则OF、CF置1 比如8位乘8位结果还是8位则CF、OF为0 有符号乘法指令IMUL单操作数1IMUL OP1 被乘数隐含在累加器中（AL,AX,EAX） 字节运算结果返回到AX 字运算 DX:AX 双字运算 EDX:EAX 双操作数1IMUL OP1, OP2; OP1 &lt;- OP1 * OP2 三操作数1IMUL OP1, OP2, OP3; OP1 &lt;- OP2 * OP3 若积的高字节、字或双字不是积的符号位扩展，则OF、CF置1，否则OF、CF请0。 除法指令DIV/IDIV12DIV OP1; 无符号除法IDIV OP1; 有符号除法 被除数隐含在AX中， OP1 （除数） 被除数 余数 余数 字节 AX AL AH 字 DX:AX AX DX 双字 EDX:EAX EAX EDX 注意被除数位数要是除数的二倍16/8 32/16 64/32 那么8位被除数怎么办 符号扩展指令1234567CBW; 将AL中8位带符号数扩展为16位存入AX。CWD; 将AX中16位带符号数扩展为32位存入DX:AXCWDE; 将AX中16位带符号数扩展为32位存入EAX。CDQ; 将EAX中32位带符号数扩展为64位存入EDX:EAX。 Tips：无论地址的位数如何，所指向的一个存储单元大小为1Byte（字节） 十进制（BCD码）调整指令压缩BCD码运算：将压缩BCD数用二进制加、减指令（ADD,SUB,ADC,SBC）运算，运算结果必须用一下调整指令调整为压缩BCD数的结果 12345678DAA; 将AL中的和调整为压缩BCD数DAS; 将AL中的差调整为压缩BCD数非压缩BCD字节数加减乘除（ASCII调整）非压缩BCD码运算：将非压缩BCD数用二进制加减乘除指令运算，配合相应的调整。AAA; (+)将AL中的和调整为非压缩BCD数AAS; (-)将AL中的差调整为非压缩BCD数AAM; (*)将AL中的积调整为非压缩BCD数AAD; (/)调整AX中的被除数，相除的商即为非压缩BCD数 1234567891011121314# 两个ASCII数想减（7-5）MOV AL, &apos;7&apos;; 37HSUB AL, &apos;5&apos;; 37H-35HAAS ; 调整，(AL)=02H# 非组合BCD数6*8=48MOV AL, O6HMOV BL, 08HMUL BL ; AX &lt;- (AL)*(BL)AAM ; 调整(AX)=0408H# 非组合BCD数17/5=3余2MOV AX, 0107HMOV BL, 05HAAD ; 调整被除数，(AX)=0011HDIV BL ; 相除，(AL)=03,(AH)=02 二进制负数运算二进制数中表示负数值时，一般会把最高位作为符号来使用，因此我们把这个最高位称为符号位。符号位是 0 时表示正数 ，符号位 是 1 时表示负数。那么－1 用 8 位二进制数来表示的话是什么样的呢？可能很多人会认为“1 的二进制数是 00000001，因此－1 就是 10000001”，但这个答案是错的，正确答案是 11111111。 计算机在做减法运算时，实际上内部是在做加法运算。用加法运算来实现减法运算，是不是很新奇呢？为此，在表示负数时就需要使用“二进制的补数”。补数就是用正数来表示负数，很不可思议吧。 为了获得补数，我们需要将二进制数的各数位的数值全部取反，然后再将结果加 1。例如，用 8 位二进制数表示－1 时，只需求得 1，也就是 00000001 的补数即可。具体来说，就是将各数位的 0 取反成 1，1 取反成 0，然后再将取反的结果加 1，最后就转化成了 11111111 “当然，结果不为 0 的运算同样可以通过使用补数来得到正确的结果。不过，有一点需要注意，当运算结果为负数时，计算结果的值也是以补数的形式来表示的。比如 3－5 这个运算，用 8 位二进制数表示 3 时为 00000011，而 5 = 00000101 的补数为“取反＋1”，也就是 11111011。因此 3－5 其实就是 00000011＋11111011 的运算。 00000011 + 11111011 的运算结果为 11111110，最高位变成了 1。这就表示结果是一个负数，这点大家应该都能理解。那么 11111110 表示的负数是多少大家知道吗？这时我们可以利用负负得正这个性质。假若 11111110 是负△△，那么 11111110 的补数就是正△△。通过求解补数的补数，就可知该值的绝对值。11111110 的补数，取反加 1 后为 00000010。这个是 2 的十进制数。因此，11111110 表示的就是－2。 仔细思考一下补数的机制，大家就会明白像－32768～32767 这样负数比正数多一个的原因了。最高位是 0 的正数，有 0～32767 共 32768 个，这其中也包含 0。最高位是 1 的负数，有－1～－32768 共 32768 个，这其中不包含 0。也就是说，0 包含在正数范围内，所以负数就要比正数多 1 个。虽然 0 不是正数，但考虑到符号位，就将其划分到了正数中。 符号拓展位符号扩充（又名符号扩展）是计算机算术中，在保留数字的符号（正负性）及数值的情况下，增加二进制数字位数的操作。此操作根据使用的特定有符号数处理方式，通过在数字的最高有效位端添加位数的方式完成。 举个例子，若计算机使用六位二进制数表示数字“00 1010”（十进制的正10），且此数字需要将字长符号扩充至十六位，则扩充后的值为“0000 0000 0000 1010”。此时，数值与符号均保留了下来。 若计算机使用十位数及二补数表示数字“11 1111 0001”（十进制的负15），且此值需要扩充至十六位，则扩充后的值为“1111 1111 1111 0001”。 此时，负号及原数字数值通过将左侧填充为1的方式保留了下来。 在英特尔的x86指令集中，符号扩充有两种方式：使用指令cbw、cwd、cwde及cdq：分别将字节转化为字、字转化为双字、字转化为扩充双字、双字转化为四倍长字（x86环境中，一个字节为8位、一个字16位、双字与扩充双字均为32位、四倍长字64位）；使用符号扩展移动指令，可通过movsx（“带符号移动”）指令族完成。 零扩展是与符号扩展类似的概念。在移动操作或转换操作中，零扩展指的是将目标的高位数设置为零，而不是将高位数设置成原数字的最高有效位。零扩展通常用于将无符号数字移动至较大的字段中，同时保留其数值；而符号扩展通常用于有符号的数字。 在x86及x64指令集中，movzx指令（“使用零扩展移动”）将执行零扩展移动。举个例子，movzx ebx, al会复制al中的一个字节至ebx的低位字节，随后使用0填充ebx的剩余字节。 在x64平台上，大多数写入通用寄存器的低32位的指令将使用0填充目标寄存器的上半部分。举个例子，指令mov eax, 1234 将清除rax寄存器的上32位。 移位运算移位运算指的是将二进制数值的各数位进行左右移位 &lt;&lt;左移 &gt;&gt;右移 逻辑右移和算术右移的区别右移有移位后在最高位补0和最高位补1两种情况 逻辑右移：移位后需要在最高位补 0。 当二进制数的值表示图形模式而非数值时，类似于霓虹灯往右滚动的效果。 算术右移：移位后要在最高位填充移位前符号位的值（0 或 1） 当二进制数作为带符号的数值进行运算时，如果数值是用补数表示的负数值，那么右移后在空出来的最高位补 1，如果是正数，只需在最高位补 0 即可。 PS 只有在右移时才必须区分逻辑位移和算术位移。左移时，无论是图形模式（逻辑左移）还是相乘运算（算术左移），都只需在空出来的低位补 0 即可 BCD码压缩BCD码：4位二进制表示一个十进制位 需要注意的是每个十进制数都用一组四位二进制数来表示。不足4位者(十进制数0到7)加添0字开头，以凑足4位。还有六种数码：1010，1011，1100，1101，1110，1111，是不用的。 非压缩BCD码：一个字节（8位二进制位）表示一个十进制位 非压缩型BCD码一个字节可存放一个一位十进制数，其中高4位的内容不做规定（也有部分书籍要求为0，二者均可），低4位二进制表示该位十进制数。如5的非压缩型BCD码是0000 0101，必须存放在一个字节中，56的非压缩型BCD码是00000101 00000110，必须存放在一个字中； 参考资料 《微机原理与接口技术》 戴胜华","categories":[],"tags":[{"name":"assembly","slug":"assembly","permalink":"onegoon.store/tags/assembly/"}]},{"title":"iOS中的对象","slug":"iOS中的对象","date":"2020-03-17T07:23:24.000Z","updated":"2020-03-19T08:10:24.441Z","comments":true,"path":"2020/03/17/iOS中的对象/","link":"","permalink":"onegoon.store/2020/03/17/iOS中的对象/","excerpt":"","text":"又到了手写weak’的时候了，再来一轮. 站在巨人的肩膀，乘后人之凉 阅读源码推荐VSCode，全称Visual Studio Code 分析OC代码，通用手段是用C++ rewrite，通过分析C++代码来了解OC底层实现 先来份完整片段 如下OC代码 Alan.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#import &lt;UIKit/UIKit.h&gt;#import &quot;AppDelegate.h&quot;@interface Human: NSObject@end@implementation Human- (void)breath &#123; NSLog(@&quot;fresh air&quot;);&#125;+ (void)eat &#123; NSLog(@&quot;raw food&quot;);&#125;@end@interface AlanWang: Human@property NSString *hack;@end@implementation AlanWang- (void)cook &#123; NSLog(@&quot;then eat&quot;);&#125;+ (void)swim &#123; NSLog(@&quot;so much water&quot;);&#125;@endint main(int argc, char * argv[]) &#123; NSString * appDelegateClassName; AlanWang *man = [AlanWang alloc]; man = [man init]; @autoreleasepool &#123; appDelegateClassName = NSStringFromClass([AppDelegate class]); &#125; return UIApplicationMain(argc, argv, nil, appDelegateClassName);&#125; rewrite xcrun -sdk iphoneos clang -rewrite-objc -F UIKit -fobjc-arc -arch arm64 Alan.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319#ifndef _REWRITER_typedef_Human#define _REWRITER_typedef_Humantypedef struct objc_object Human;typedef struct &#123;&#125; _objc_exc_Human;#endifstruct Human_IMPL &#123; struct NSObject_IMPL NSObject_IVARS;&#125;;/* @end */// @implementation Humanstatic void _I_Human_breath(Human * self, SEL _cmd) &#123; NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_1f_vycdcqqn5r32n45pwpqrj1gr0000gn_T_Alan_02f76f_mi_0);&#125;static void _C_Human_eat(Class self, SEL _cmd) &#123; NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_1f_vycdcqqn5r32n45pwpqrj1gr0000gn_T_Alan_02f76f_mi_1);&#125;// @end#ifndef _REWRITER_typedef_AlanWang#define _REWRITER_typedef_AlanWangtypedef struct objc_object AlanWang;typedef struct &#123;&#125; _objc_exc_AlanWang;#endifextern \"C\" unsigned long OBJC_IVAR_$_AlanWang$_hack;struct AlanWang_IMPL &#123; struct Human_IMPL Human_IVARS; NSString *__strong _hack;&#125;;// @property NSString *hack;/* @end */// @implementation AlanWangstatic void _I_AlanWang_cook(AlanWang * self, SEL _cmd) &#123; NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_1f_vycdcqqn5r32n45pwpqrj1gr0000gn_T_Alan_02f76f_mi_2);&#125;static void _C_AlanWang_swim(Class self, SEL _cmd) &#123; NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_1f_vycdcqqn5r32n45pwpqrj1gr0000gn_T_Alan_02f76f_mi_3);&#125;static NSString * _I_AlanWang_hack(AlanWang * self, SEL _cmd) &#123; return (*(NSString *__strong *)((char *)self + OBJC_IVAR_$_AlanWang$_hack)); &#125;static void _I_AlanWang_setHack_(AlanWang * self, SEL _cmd, NSString *hack) &#123; (*(NSString *__strong *)((char *)self + OBJC_IVAR_$_AlanWang$_hack)) = hack; &#125;// @endint main(int argc, char * argv[]) &#123; NSString * appDelegateClassName; AlanWang *man = ((AlanWang *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"AlanWang\"), sel_registerName(\"alloc\")); man = ((AlanWang *(*)(id, SEL))(void *)objc_msgSend)((id)man, sel_registerName(\"init\")); /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; appDelegateClassName = NSStringFromClass(((Class (*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"AppDelegate\"), sel_registerName(\"class\"))); &#125; return UIApplicationMain(argc, argv, __null, appDelegateClassName);&#125;struct _prop_t &#123; const char *name; const char *attributes;&#125;;struct _protocol_t;struct _objc_method &#123; struct objc_selector * _cmd; const char *method_type; void *_imp;&#125;;struct _protocol_t &#123; void * isa; // NULL const char *protocol_name; const struct _protocol_list_t * protocol_list; // super protocols const struct method_list_t *instance_methods; const struct method_list_t *class_methods; const struct method_list_t *optionalInstanceMethods; const struct method_list_t *optionalClassMethods; const struct _prop_list_t * properties; const unsigned int size; // sizeof(struct _protocol_t) const unsigned int flags; // = 0 const char ** extendedMethodTypes;&#125;;struct _ivar_t &#123; unsigned long int *offset; // pointer to ivar offset location const char *name; const char *type; unsigned int alignment; unsigned int size;&#125;;struct _class_ro_t &#123; unsigned int flags; unsigned int instanceStart; unsigned int instanceSize; const unsigned char *ivarLayout; const char *name; const struct _method_list_t *baseMethods; const struct _objc_protocol_list *baseProtocols; const struct _ivar_list_t *ivars; const unsigned char *weakIvarLayout; const struct _prop_list_t *properties;&#125;;struct _class_t &#123; struct _class_t *isa; struct _class_t *superclass; void *cache; void *vtable; struct _class_ro_t *ro;&#125;;struct _category_t &#123; const char *name; struct _class_t *cls; const struct _method_list_t *instance_methods; const struct _method_list_t *class_methods; const struct _protocol_list_t *protocols; const struct _prop_list_t *properties;&#125;;extern \"C\" __declspec(dllimport) struct objc_cache _objc_empty_cache;#pragma warning(disable:4273)static struct /*_method_list_t*/ &#123; unsigned int entsize; // sizeof(struct _objc_method) unsigned int method_count; struct _objc_method method_list[1];&#125; _OBJC_$_INSTANCE_METHODS_Human __attribute__ ((used, section (\"__DATA,__objc_const\"))) = &#123; sizeof(_objc_method), 1, &#123;&#123;(struct objc_selector *)\"breath\", \"v16@0:8\", (void *)_I_Human_breath&#125;&#125;&#125;;static struct /*_method_list_t*/ &#123; unsigned int entsize; // sizeof(struct _objc_method) unsigned int method_count; struct _objc_method method_list[1];&#125; _OBJC_$_CLASS_METHODS_Human __attribute__ ((used, section (\"__DATA,__objc_const\"))) = &#123; sizeof(_objc_method), 1, &#123;&#123;(struct objc_selector *)\"eat\", \"v16@0:8\", (void *)_C_Human_eat&#125;&#125;&#125;;static struct _class_ro_t _OBJC_METACLASS_RO_$_Human __attribute__ ((used, section (\"__DATA,__objc_const\"))) = &#123; 1, sizeof(struct _class_t), sizeof(struct _class_t), 0, \"Human\", (const struct _method_list_t *)&amp;_OBJC_$_CLASS_METHODS_Human, 0, 0, 0, 0, &#125;;static struct _class_ro_t _OBJC_CLASS_RO_$_Human __attribute__ ((used, section (\"__DATA,__objc_const\"))) = &#123; 0, sizeof(struct Human_IMPL), sizeof(struct Human_IMPL), 0, \"Human\", (const struct _method_list_t *)&amp;_OBJC_$_INSTANCE_METHODS_Human, 0, 0, 0, 0, &#125;;extern \"C\" __declspec(dllimport) struct _class_t OBJC_METACLASS_$_NSObject;extern \"C\" __declspec(dllexport) struct _class_t OBJC_METACLASS_$_Human __attribute__ ((used, section (\"__DATA,__objc_data\"))) = &#123; 0, // &amp;OBJC_METACLASS_$_NSObject, 0, // &amp;OBJC_METACLASS_$_NSObject, 0, // (void *)&amp;_objc_empty_cache, 0, // unused, was (void *)&amp;_objc_empty_vtable, &amp;_OBJC_METACLASS_RO_$_Human,&#125;;extern \"C\" __declspec(dllimport) struct _class_t OBJC_CLASS_$_NSObject;extern \"C\" __declspec(dllexport) struct _class_t OBJC_CLASS_$_Human __attribute__ ((used, section (\"__DATA,__objc_data\"))) = &#123; 0, // &amp;OBJC_METACLASS_$_Human, 0, // &amp;OBJC_CLASS_$_NSObject, 0, // (void *)&amp;_objc_empty_cache, 0, // unused, was (void *)&amp;_objc_empty_vtable, &amp;_OBJC_CLASS_RO_$_Human,&#125;;static void OBJC_CLASS_SETUP_$_Human(void ) &#123; OBJC_METACLASS_$_Human.isa = &amp;OBJC_METACLASS_$_NSObject; OBJC_METACLASS_$_Human.superclass = &amp;OBJC_METACLASS_$_NSObject; OBJC_METACLASS_$_Human.cache = &amp;_objc_empty_cache; OBJC_CLASS_$_Human.isa = &amp;OBJC_METACLASS_$_Human; OBJC_CLASS_$_Human.superclass = &amp;OBJC_CLASS_$_NSObject; OBJC_CLASS_$_Human.cache = &amp;_objc_empty_cache;&#125;extern \"C\" unsigned long int OBJC_IVAR_$_AlanWang$_hack __attribute__ ((used, section (\"__DATA,__objc_ivar\"))) = __OFFSETOFIVAR__(struct AlanWang, _hack);static struct /*_ivar_list_t*/ &#123; unsigned int entsize; // sizeof(struct _prop_t) unsigned int count; struct _ivar_t ivar_list[1];&#125; _OBJC_$_INSTANCE_VARIABLES_AlanWang __attribute__ ((used, section (\"__DATA,__objc_const\"))) = &#123; sizeof(_ivar_t), 1, &#123;&#123;(unsigned long int *)&amp;OBJC_IVAR_$_AlanWang$_hack, \"_hack\", \"@\\\"NSString\\\"\", 3, 8&#125;&#125;&#125;;static struct /*_method_list_t*/ &#123; unsigned int entsize; // sizeof(struct _objc_method) unsigned int method_count; struct _objc_method method_list[3];&#125; _OBJC_$_INSTANCE_METHODS_AlanWang __attribute__ ((used, section (\"__DATA,__objc_const\"))) = &#123; sizeof(_objc_method), 3, &#123;&#123;(struct objc_selector *)\"cook\", \"v16@0:8\", (void *)_I_AlanWang_cook&#125;, &#123;(struct objc_selector *)\"hack\", \"@16@0:8\", (void *)_I_AlanWang_hack&#125;, &#123;(struct objc_selector *)\"setHack:\", \"v24@0:8@16\", (void *)_I_AlanWang_setHack_&#125;&#125;&#125;;static struct /*_method_list_t*/ &#123; unsigned int entsize; // sizeof(struct _objc_method) unsigned int method_count; struct _objc_method method_list[1];&#125; _OBJC_$_CLASS_METHODS_AlanWang __attribute__ ((used, section (\"__DATA,__objc_const\"))) = &#123; sizeof(_objc_method), 1, &#123;&#123;(struct objc_selector *)\"swim\", \"v16@0:8\", (void *)_C_AlanWang_swim&#125;&#125;&#125;;static struct /*_prop_list_t*/ &#123; unsigned int entsize; // sizeof(struct _prop_t) unsigned int count_of_properties; struct _prop_t prop_list[1];&#125; _OBJC_$_PROP_LIST_AlanWang __attribute__ ((used, section (\"__DATA,__objc_const\"))) = &#123; sizeof(_prop_t), 1, &#123;&#123;\"hack\",\"T@\\\"NSString\\\",&amp;,V_hack\"&#125;&#125;&#125;;static struct _class_ro_t _OBJC_METACLASS_RO_$_AlanWang __attribute__ ((used, section (\"__DATA,__objc_const\"))) = &#123; 1, sizeof(struct _class_t), sizeof(struct _class_t), 0, \"AlanWang\", (const struct _method_list_t *)&amp;_OBJC_$_CLASS_METHODS_AlanWang, 0, 0, 0, 0, &#125;;static struct _class_ro_t _OBJC_CLASS_RO_$_AlanWang __attribute__ ((used, section (\"__DATA,__objc_const\"))) = &#123; 0, __OFFSETOFIVAR__(struct AlanWang, _hack), sizeof(struct AlanWang_IMPL), 0, \"AlanWang\", (const struct _method_list_t *)&amp;_OBJC_$_INSTANCE_METHODS_AlanWang, 0, (const struct _ivar_list_t *)&amp;_OBJC_$_INSTANCE_VARIABLES_AlanWang, 0, (const struct _prop_list_t *)&amp;_OBJC_$_PROP_LIST_AlanWang,&#125;;extern \"C\" __declspec(dllexport) struct _class_t OBJC_METACLASS_$_Human;extern \"C\" __declspec(dllimport) struct _class_t OBJC_METACLASS_$_NSObject;extern \"C\" __declspec(dllexport) struct _class_t OBJC_METACLASS_$_AlanWang __attribute__ ((used, section (\"__DATA,__objc_data\"))) = &#123; 0, // &amp;OBJC_METACLASS_$_NSObject, 0, // &amp;OBJC_METACLASS_$_Human, 0, // (void *)&amp;_objc_empty_cache, 0, // unused, was (void *)&amp;_objc_empty_vtable, &amp;_OBJC_METACLASS_RO_$_AlanWang,&#125;;extern \"C\" __declspec(dllexport) struct _class_t OBJC_CLASS_$_Human;extern \"C\" __declspec(dllexport) struct _class_t OBJC_CLASS_$_AlanWang __attribute__ ((used, section (\"__DATA,__objc_data\"))) = &#123; 0, // &amp;OBJC_METACLASS_$_AlanWang, 0, // &amp;OBJC_CLASS_$_Human, 0, // (void *)&amp;_objc_empty_cache, 0, // unused, was (void *)&amp;_objc_empty_vtable, &amp;_OBJC_CLASS_RO_$_AlanWang,&#125;;static void OBJC_CLASS_SETUP_$_AlanWang(void ) &#123; OBJC_METACLASS_$_AlanWang.isa = &amp;OBJC_METACLASS_$_NSObject; OBJC_METACLASS_$_AlanWang.superclass = &amp;OBJC_METACLASS_$_Human; OBJC_METACLASS_$_AlanWang.cache = &amp;_objc_empty_cache; OBJC_CLASS_$_AlanWang.isa = &amp;OBJC_METACLASS_$_AlanWang; OBJC_CLASS_$_AlanWang.superclass = &amp;OBJC_CLASS_$_Human; OBJC_CLASS_$_AlanWang.cache = &amp;_objc_empty_cache;&#125;#pragma section(\".objc_inithooks$B\", long, read, write)__declspec(allocate(\".objc_inithooks$B\")) static void *OBJC_CLASS_SETUP[] = &#123; (void *)&amp;OBJC_CLASS_SETUP_$_Human, (void *)&amp;OBJC_CLASS_SETUP_$_AlanWang,&#125;;static struct _class_t *L_OBJC_LABEL_CLASS_$ [2] __attribute__((used, section (\"__DATA, __objc_classlist,regular,no_dead_strip\")))= &#123; &amp;OBJC_CLASS_$_Human, &amp;OBJC_CLASS_$_AlanWang,&#125;;static struct IMAGE_INFO &#123; unsigned version; unsigned flag; &#125; _OBJC_IMAGE_INFO = &#123; 0, 2 &#125;; 可以搜索关键字AlanWang来定位代码，当然往往都在最下面 不难发现c++重写后OC类被加了前缀 OBJC_CLASS_REF_$_ OBJC_CLASS_$_ OBJC_METACLASS_$_ 查阅Swift源码可见的确是这些前缀。可见在rewrite过程中总会被加一些标识前缀，所以阅读时自行转化前缀 123456789101112131415161718192021222324252627// An Objective-C class reference reference. The symbol is private, so // the mangling is unimportant; it should just be readable in LLVM IR.case Kind::ObjCClassRef: &#123; llvm::SmallString&lt;64&gt; tempBuffer; StringRef name = cast&lt;ClassDecl&gt;(getDecl())-&gt;getObjCRuntimeName(tempBuffer); std::string Result(\"OBJC_CLASS_REF_$_\"); Result.append(name.data(), name.size()); return Result;&#125; // An Objective-C class reference; not a swift mangling.case Kind::ObjCClass: &#123; llvm::SmallString&lt;64&gt; TempBuffer; StringRef Name = cast&lt;ClassDecl&gt;(getDecl())-&gt;getObjCRuntimeName(TempBuffer); std::string Result(\"OBJC_CLASS_$_\"); Result.append(Name.data(), Name.size()); return Result;&#125; // An Objective-C metaclass reference; not a swift mangling.case Kind::ObjCMetaclass: &#123; llvm::SmallString&lt;64&gt; TempBuffer; StringRef Name = cast&lt;ClassDecl&gt;(getDecl())-&gt;getObjCRuntimeName(TempBuffer); std::string Result(\"OBJC_METACLASS_$_\"); Result.append(Name.data(), Name.size()); return Result;&#125; 先来看两个类的初始化方法 extern “C” 的意思是把它当做C语言编译 比如C++支持重载，而C不支持 1extern \"C\" __declspec(dllexport) struct _class_t OBJC_CLASS_$_Human; 1234567extern \"C\" __declspec(dllexport) struct _class_t OBJC_CLASS_$_AlanWang __attribute__ ((used, section (\"__DATA,__objc_data\"))) = &#123; 0, // &amp;OBJC_METACLASS_$_AlanWang, 0, // &amp;OBJC_CLASS_$_Human, 0, // (void *)&amp;_objc_empty_cache, 0, // unused, was (void *)&amp;_objc_empty_vtable, &amp;_OBJC_CLASS_RO_$_AlanWang,&#125;; AlanWang 这个类被存在&quot;__DATA, __objc_classlist,regular,no_dead_strip&quot;section中 _class_t1234567struct _class_t &#123; struct _class_t *isa; struct _class_t *superclass; void *cache; void *vtable; struct _class_ro_t *ro;&#125;; _class_t 的 isa 和 superclass 指向 _class_t SETUP AlanWang12345678static void OBJC_CLASS_SETUP_$_AlanWang(void ) &#123; OBJC_METACLASS_$_AlanWang.isa = &amp;OBJC_METACLASS_$_NSObject; OBJC_METACLASS_$_AlanWang.superclass = &amp;OBJC_METACLASS_$_Human; OBJC_METACLASS_$_AlanWang.cache = &amp;_objc_empty_cache; OBJC_CLASS_$_AlanWang.isa = &amp;OBJC_METACLASS_$_AlanWang; OBJC_CLASS_$_AlanWang.superclass = &amp;OBJC_CLASS_$_Human; OBJC_CLASS_$_AlanWang.cache = &amp;_objc_empty_cache;&#125; SETUP Human12345678static void OBJC_CLASS_SETUP_$_Human(void ) &#123; OBJC_METACLASS_$_Human.isa = &amp;OBJC_METACLASS_$_NSObject; OBJC_METACLASS_$_Human.superclass = &amp;OBJC_METACLASS_$_NSObject; OBJC_METACLASS_$_Human.cache = &amp;_objc_empty_cache; OBJC_CLASS_$_Human.isa = &amp;OBJC_METACLASS_$_Human; OBJC_CLASS_$_Human.superclass = &amp;OBJC_CLASS_$_NSObject; OBJC_CLASS_$_Human.cache = &amp;_objc_empty_cache;&#125; 一图胜千言。 _class_ro_t123456789101112struct _class_ro_t &#123; unsigned int flags; unsigned int instanceStart; unsigned int instanceSize; const unsigned char *ivarLayout; const char *name; const struct _method_list_t *baseMethods; const struct _objc_protocol_list *baseProtocols; const struct _ivar_list_t *ivars; const unsigned char *weakIvarLayout; const struct _prop_list_t *properties;&#125;; ro readonly 12345struct _objc_method &#123; struct objc_selector * _cmd; const char *method_type; void *_imp;&#125;; Type Encodings](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1) 源码面前无秘密 运行时类的结构随着Apple日渐开源，对于iOSer无疑来说是个福音，不必再面向黑盒开发处处靠猜，可以知其然更知其所以然。 objc源代码下载 目前最新的是objc4-779.1 objc.h 当初第一次见到这些有如久旱逢甘霖 -^- 123456789101112131415161718192021222324252627/* * objc.h * Copyright 1988-1996, NeXT Software, Inc. */#if !OBJC_TYPES_DEFINED/// An opaque type that represents an Objective-C class.typedef struct objc_class *Class;/// Represents an instance of a class.struct objc_object &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;&#125;;/// A pointer to an instance of a class.typedef struct objc_object *id;#endif/// An opaque type that represents a method selector.typedef struct objc_selector *SEL;/// A pointer to the function of a method implementation. #if !OBJC_OLD_DISPATCH_PROTOTYPEStypedef void (*IMP)(void /* id, SEL, ... */ ); #elsetypedef id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...); #endif Class 意为一个不透明的类型（指针） 代表一个Objective-C的类 id 意为类的实例的指针 SEL 意为一个不透明的类型 代表一个方法选择器 IMP 意为方法实现的函数指针 123456789101112131415/* * objc-api.h *//* OBJC_OLD_DISPATCH_PROTOTYPES == 0 enforces the rule that the dispatch * functions must be cast to an appropriate function pointer type. */#if !defined(OBJC_OLD_DISPATCH_PROTOTYPES)# if __swift__ // Existing Swift code expects IMP to be Comparable. // Variadic IMP is comparable via OpaquePointer; non-variadic IMP isn't.# define OBJC_OLD_DISPATCH_PROTOTYPES 1# else# define OBJC_OLD_DISPATCH_PROTOTYPES 0# endif#endif 如果有swift的代码。则可变的IMP是不透明指针，不可变则不是。 OBJC_TYPES_DEFINED` 宏定义是因为在另一处 objc-private.h中也有声明 避免重复定义 1234567891011121314151617181920212223242526272829303132/* * objc-private.h * Copyright 1988-1996, NeXT Software, Inc. */ #define OBJC_TYPES_DEFINED 1 struct objc_class;struct objc_object;typedef struct objc_class *Class;typedef struct objc_object *id;namespace &#123; struct SideTable;&#125;;#include \"isa.h\"union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits;#if defined(ISA_BITFIELD) struct &#123; ISA_BITFIELD; // defined in isa.h &#125;;#endif&#125;;... 友情提示 逆向的过程中注意程序或者工具运行的环境是在手机上还是在电脑上 否则会出现一些无法预知的问题 比如，Mac上开启多个terminal。有的是控制本电脑的，有的是连接shell控制手机的，很容易搞混了，， 如果容易搞混的可以开启系统自带的Terminal控制一端，再安装iTerm控制另一端 Meta 元类","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"onegoon.store/tags/iOS/"}]},{"title":"逆向","slug":"逆向","date":"2020-03-13T16:21:03.000Z","updated":"2020-03-13T16:21:03.540Z","comments":true,"path":"2020/03/14/逆向/","link":"","permalink":"onegoon.store/2020/03/14/逆向/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"小程序","slug":"小程序","date":"2020-03-13T16:19:49.000Z","updated":"2020-03-13T16:19:49.182Z","comments":true,"path":"2020/03/14/小程序/","link":"","permalink":"onegoon.store/2020/03/14/小程序/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"链接","slug":"链接","date":"2020-03-13T16:19:26.000Z","updated":"2020-03-13T16:19:26.591Z","comments":true,"path":"2020/03/14/链接/","link":"","permalink":"onegoon.store/2020/03/14/链接/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"HTML+CSS+JS","slug":"HTML-CSS-JS","date":"2020-03-13T16:05:26.000Z","updated":"2020-03-13T16:05:26.389Z","comments":true,"path":"2020/03/14/HTML-CSS-JS/","link":"","permalink":"onegoon.store/2020/03/14/HTML-CSS-JS/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"android","slug":"android","date":"2020-03-13T16:04:56.000Z","updated":"2020-03-13T16:04:56.799Z","comments":true,"path":"2020/03/14/android/","link":"","permalink":"onegoon.store/2020/03/14/android/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"flutter","slug":"flutter","date":"2020-03-13T16:03:41.000Z","updated":"2020-03-14T17:24:33.586Z","comments":true,"path":"2020/03/14/flutter/","link":"","permalink":"onegoon.store/2020/03/14/flutter/","excerpt":"","text":"感谢中文翻译组织，但是我建议如果英语好的还是直接看英文文档，翻译可能有缺漏。 英文 flutter 官网 flutter 中文网 “驼峰命名法” (称为 “upper camel case” 或 “Pascal case” ), 表示字符串中的每个单词（包括第一个单词）都以大写字母开头。所以，“uppercamelcase” 变成 “UpperCamelCase” 参考资料flutter 官网 flutter 中文网","categories":[],"tags":[{"name":"hybrid, flutter","slug":"hybrid-flutter","permalink":"onegoon.store/tags/hybrid-flutter/"}]},{"title":"Swift-Struct","slug":"Swift-Struct","date":"2020-03-13T14:27:50.000Z","updated":"2020-03-13T15:21:12.629Z","comments":true,"path":"2020/03/13/Swift-Struct/","link":"","permalink":"onegoon.store/2020/03/13/Swift-Struct/","excerpt":"","text":"vectorunion参考资料Working with Vectors Using Imported C Structs and Unions in Swift","categories":[],"tags":[{"name":"swift","slug":"swift","permalink":"onegoon.store/tags/swift/"}]},{"title":" 网络篇","slug":"网络篇","date":"2020-03-09T07:38:51.000Z","updated":"2020-03-13T01:32:01.059Z","comments":true,"path":"2020/03/09/网络篇/","link":"","permalink":"onegoon.store/2020/03/09/网络篇/","excerpt":"Q: 两台服务器A和B的网络配置， A B IP address 192.168.26.129 192.168.26.3 Subnet mask 255.255.255.0 255.255.255.224 Default gateway 192.168.26.2 192.168.26.2 子网掩码本都为255.255.255.0， B的子网掩码不小心配成了255.255.255.224。它们还能正常通信吗？ 如果看到这个问题能自信回答。下文无须再看。","text":"Q: 两台服务器A和B的网络配置， A B IP address 192.168.26.129 192.168.26.3 Subnet mask 255.255.255.0 255.255.255.224 Default gateway 192.168.26.2 192.168.26.2 子网掩码本都为255.255.255.0， B的子网掩码不小心配成了255.255.255.224。它们还能正常通信吗？ 如果看到这个问题能自信回答。下文无须再看。 名词理解IPip地址 不要被地址前的ip吓到，ip地址也是地址，位置的标识。 先来感受一下 IPv4地址 192.168.18.4 字面上分析：由3个点分为4组，可以是16进制也可以是10进制，32位 IPv6地址 2020:8210:242a:f270:1ca2:3f7:6ff:18af 字面上分析：由7个冒号分为8块也叫字段，16进制表示，128位 在IPv6中地址长度是128位，是IPv4的四倍。 1.在一个块中前导的零不必书写 2.全零的块可以省略，用符号::代替，为了避免歧义，一个IPv6地址中::只能用一次。 在某些情况下（例如表示一个包含地址的URL时），IPv6地址中的冒号分隔符可能与其他分隔符混淆，例如IP地址和端口号之间使用的冒号。这时候用[和]包围IPv6地址。例如，URL ​ http://[2001:0db8:85a3:08d3:1319:8a2e:0370:7344]:443/ 是指IPv6主机2001:0db8:85a3:08d3:1319:8a2e:0370:7344中的端口号443使用HTTP 、TCP和IPv6协议 增加的这些灵活性随之而来的就是会造成不必要的混淆性，同一个IP地址有多种的表示方式。 为了弥补这种情况，还要兼容特性，制定了规则，保证IP地址表示的唯一性 前导的零必须压缩。 符号::只能用于影响最大的地方（压缩最多的零），如果多少块中包含等长度的零，顺序靠前的块被替换为::。 a到f的十六进制数字应该用小写表示。 互联网上的每个接口必须有一个唯一的 I n t e r n e t 地址,也称作 I P 地址 IP地址的历史演变最初定义 Internet地址结构 = 网络号 + 主机号 网络号： 用于识别接口使用的IP地址在哪个网络中可被发现； 主机号：用于识别由网络部分给出的网络中的特定主机； 当时，大多数主机只有一个网络接口，因此术语接口地址和主机地址有时交替使用。 分类寻址 column 避免歧义，论证我的观点 IP地址分为A、B、C、D、E五类这是没有争议的。 但是我对E的前缀码有所怀疑 下表来自Wikipedia https://zh.wikipedia.org/wiki/IP%E5%9C%B0%E5%9D%80 A类IPv4地址 B类IPv4地址 C类IPv4地址 D类IPv4地址 E类IPv4地址 网络标志位 0 10 110 1110 11110 IP地址范围 1.0.0.0~127.255.255.255 128.0.0.0~191.255.255.255 192.0.0.0~223.255.255.255 224.0.0.0~239.255.255.255 240.0.0.0~247.255.255.255 可用IP地址范围 1.0.0.1~127.255.255.254 128.0.0.1~191.255.255.254 192.0.0.1~223.255.255.254 是否可以分配给主机使用 是 是 是 否 否 网络数量（个） 126 (27-2) 16384 (214) 2097152 (221) — — 每个网络中可容纳主机数（个） 16777214 (224-2) 65534 (216-2) 254 (28-2) — — 适用范围 大量主机的大型网络 中等规模主机数的网络 小型局域网 留给Internet体系结构委员会(IAB)使用【组播地址】 保留，仅作为搜索、Internet的实验和开发用 下图信息来自《TCP/IP详解 卷1：协议》译者: 范建华等 以上两处信息表达一致。但是我得疑问是如果E的前缀码是11110 那么剩下的那个区间的地址算什么 11111000 00000000 00000000 00000000 ~ 11111111 11111111 11111111 11111111 248.0.0.0 ~255.255.255.255 又查阅了《TCP/IP详解 卷1：协议》第二版，吴英等译 吴功宜 审校 E类的 地址范围 240.0.0.0 ~ 255.255.255.255 高位序 1111 我还是倾向于后者,所以之后的理论基于此，尽管这无关紧要。 现实中的不同网络可能有不同数量的主机，每台主机都需要一个唯一IP地址。 地址空间的划分涉及五大类，每类都基于网络中可容纳的主机数量，确定在一个32位的IPv地址中分配给网络号和主机号的位数。 由上图的信息可以算得下表数据 类 地址范围 高序位 用途 百分比 网络数 主机数 A 0.0.0.0~127.255.255.255 0 单播/特殊 1/2 128 (2^7) 16777216 (2^24) B 128.0.0.0~191.255.255.255 10 单播/特殊 1/4 16384 (2^14) 65536 (2^16) C 192.0.0.0~223.255.255.255 110 单播/特殊 1/8 2097152 (2^21) 256 (2^8) D 224.0.0.0~239.255.255.255 1110 组播 1/16 N/A N/A E 240.0.0.0~255.255.255.255 1111 保留 1/16 N/A N/A 百分比的计算可以 画棵哈夫曼树， 比如 0为左子树1为右子树 各类的网络数呈几何倍的递增，而网络数却呈几何倍递减，这样的分类有些脱离现实过于数字化了。 A类和B类网络号通常浪费太多主机号，而C类网络号则不能为很多站点提供足够的主机号。 比如C类网络号主机过少，而B类网络号主机又过多，如果想选择一个千为单位的网络号则十分尴尬了。 子网寻址背负历史包袱，负重前行 为了在不改变Internet核心路由基础设施的情况下解决这个问题，人们很自然想到一种方式，在一个站点接入Internet后为其分配一个网络号，然后又站点管理员进一步划分本地的子网数。 实现这个想法需要改变IP地址的网路部分和主机部分的限制，但这样做只是针对一个站点自身而言；Internet其余部分将只能’看到‘传统的A类、B类和C类部分。支持此功能的方法称为子网寻址。 解释一下，一个站点可能申请到了B类网络号，也就是IP地址的前16位确定了，余下16位自由位， 如果按照传统思维（分类寻址）那么剩下的16位就是主机号， 而按照子网寻址的逻辑，这16位对于Internet其他部分看来依然是主机号，对于站点自身来看，可通过子网掩码自由再划分成网络号与主机号。如下图一种可能的格式 这个例子中为一个B类地址被划分子网。它使用8位作为子网ID，提供256个子网和每个子网中254台主机（当前每个子网的第一个和最后一个地址无效，即从整个分配范围中去除第一个和最后一个地址）。这种划分可由网络管理员改变 前16位有权威机构分配。该站点的每个地址前16位固定不变，后16位由管理员分配。 注意只有划分子网的网络中的主机和路由器知道子网结构，在进行子网寻址前，Internet其他部分仍将它作为站点相关地址来看待。 下图展示如何工作 某个站点被分配一个典型的B类网络号128.32 。 网络管理员决定用于站点范围内的子网掩码为255.255.255.0,提供256个子网，每个子网可容纳256-2 = 254台主机。同一子网中每台主机的IPv4地址拥有相同子网号。左侧的局域网段中主机的IPv4地址开始于128.32.1，右侧的所有主机开始于128.32.2 。 Internet中其他站点要访问这个站点目的地址以128.32开始的所有流量直接由Internet路由系统交给边界路由器，如137.64.23.30要访问128.32.1.1 则先访问到站点边界路由器，边界路由器区分128.32网络中的不同子网。比如图中，它则要区分目的地址为128.32.1.x和目的地址为128.32.2.x的流量。这些地址分别表示子网号1和2，它们都采用128.32的B类网络号。那么路由器如何在地址中找到子网ID，这就需要子网掩码了。 子网掩码子网掩码是由一台主机或路由器使用的分配位，以确定如何从一台主机对应IP地址中获得网络和子网信息。IP子网掩码与对应的IP地址长度相同（IPv4为32位，IPv6为128位）。它们通常在一台主机或路由器中以IP地址相同的方式配置，既可以是静态的（通常是路由器），也可以是动态的（例如动态主机配置协议DHCP）。 子网掩码表示网络号与主机号的边界，全是1的那边表示网络号全是0的表示主机号 如IPv4地址为128.32.1.14/255.255.255.0 地址（128.32.1.14） 10000000 00100000 00000001 00001110 掩码（255.255.255.0） 11111111 11111111 11111111 00000000 按位与结果 （128.32.1.0） 10000000 00100000 00000001 00000000 （网络号和地址）按位异或结果 00000000 00000000 00000000 00001110 网络号为 128.32.1.0 子网主机ID为 14 可变长度子网掩码VLSM同一站点的不同部分，可将不同长度的子网掩码应用于相同网络号 回顾前文的问题 Q: 两台服务器A和B的网络配置， A B IP address 192.168.26.129 192.168.26.3 Subnet mask 255.255.255.0 255.255.255.224 Default gateway 192.168.26.2 192.168.26.2 子网掩码本都为255.255.255.0， B的子网掩码不小心配成了255.255.255.224。它们还能正常通信吗？ A的地址 192.169.26.129/24 如果没有配置错则A与B在同一个子网内192.168.26.0 而现在B地址为 192.168.26.3/27 已经了解历史VLSM的原理 ，我们可以简单的绘制网络拓扑 A与B掩码不同处于不同层次的子网，但是依然处于192.168.26.x的结点下。通信是一定可以的，只是方式有所转变。 当讲解完Wireshark后，后再抓包分析这个流程 CIDR和聚合20世纪90年代初，采用子网寻址缓解增长带来的痛苦后，Internet开始面临更严重的规模问题。有三个问题尤为重要。 到1994年，一半以上的B类地址已被分配。预计B类地址空间大约在1995年将被用尽。 32位的IPv4地址被认为不足以应付Internet在21世纪的初期规模。 全球性路由表的条目数（每个网络数对应一条），1995年大约为65000个条目，目前仍在增长。伴随着越来越多的ABC类路由条目出现，路由性能受到影响。 前缀前文讲到的子网寻址方式base于分类寻址之上的。虽然对站点内的情况有所改善，但是对于整体Internet依然面临着严峻的问题（如为新站点选择网络号） 为了缓解IPv4的地址的压力，无类别域间路由CIDR应运而生。 CIDR无类别域间路由顾名思义，CIDR意在消除类别，即消除IP地址中网络和主机号的预定义分隔，将更细粒度的IP地址分配范围成为可能。 使用CIDR，未经过预定义的任何地址范围可作为一个类的一部分，但需要一个类似于子网掩码的掩码，有时也称为CIDR掩码。使用CIDR掩码不再局限于一个站点，而对全球路由系统都是可见的。因此，除了网络号之外，核心Internet路由器必须能解释和处理掩码。这个数字组合称为网络前缀,它用于IPv4和IPv6地址管理。 暂且理解为 CIDR 为 子网掩码的Internet版。 聚合通过取消分类结构的IP地址，能分配各种尺寸的IP地址块。但是，这样做没有解决问题3. 它并未有助于减少路由条目数。 路由条目：路由器发送流量的指向 从本质上来说，路由器检查每个到达的数据报中的目的IP地址，找到一条匹配的路由表条目，并从该条目中提取数据报的”下一跳“。 分层路由20世纪70年代末，由Kleinrock和Kamoun发表的分层路由研究 如果将网络拓扑排列为一棵树，并且以对网络拓扑敏感的方式来分配地址，可获得一个非常小的路由表，同时保持到所有目的地最短路径，下图举个例子 左侧a)图中的树根是标记为19.12.4.8的路由器。为了知道每个可能的目的地的下一跳，它需要知道一棵树中在其下面的所有路由的条目，所以其存有的路由条目共9条。 右侧b)图中的树根是标记为19.0.0.1，并要求其路由表中只3个条目（二叉树）左子树中所有路由器（节点）以前缀19.1开始，右侧的所有路由器以19.2开始。因此。路由器19.0.0.1的表中只需将19.1开始的目的地显示下一跳为19.1.0.1而将以19.2开始的目的地下一跳显示为19.2.0.1 。 任何其他的目的地址都被路由到标有”网络其他部分“的云中。结果共有3个条目（父结点，子结点） 路由聚合通过将相邻的多个IP前缀合并成一个短前缀称为一个聚合或汇聚 前两个（190.154.27.0/26与190.154.27.64/26）数值相邻，因此可被聚合。前缀190.154.27.192/26不能被聚合，由于它们并非数值相邻。 这样原来的三个前缀和两个新增的前缀可聚合成一个前缀。 特殊用途地址IPv4和IPv6地址空间中都包括几个地址范围，它们被用于特殊用途，因此不能用于单播地址分配。 这些特殊地址不详谈了。 还有一些单播地址被用于构建专用网络，来自这些范围的地址可用于一个站点或组织内部的主机和路由器之间的通信，但不能用于Internet中。因此这些地址有时也被称为不可路由的地址。 专用、不可路由的地址空间管理完全由本地决定。IPv4专用地址在家庭网络、中等规模、大型企业内部网络中很常见。它们经常与网络地址转换（NAT）结合使用，在IP数据报进入Internet时修改其中的IP地址。 这些构建内网的IP常称为私有IP IPv4前缀 10/8 172.16/12和192.168/16， IPv6前缀 fc00::/7 Private IPv4 addresses The Internet Engineering Task Force (IETF) has directed the Internet Assigned Numbers Authority (IANA) to reserve the following IPv4 address ranges for private networks RFC1918 name IP address range Number of addresses Largest CIDR block (subnet mask) Host ID size Mask bits Classful description[Note 1] 24-bit block 10.0.0.0 – 10.255.255.255 16777216 10.0.0.0/8 (255.0.0.0) 24 bits 8 bits single class A network 20-bit block 172.16.0.0 – 172.31.255.255 1048576 172.16.0.0/12 (255.240.0.0) 20 bits 12 bits 16 contiguous class B networks 16-bit block 192.168.0.0 – 192.168.255.255 65536 192.168.0.0/16 (255.255.0.0) 16 bits 16 bits 256 contiguous class C networks 简化后如下图 大致感受一下中小企业的网络拓扑 IP地址结构 大多数IPv4地址块最终被细分为一个地址用于识别连接Internet或者某些专用的内联网的计算机网络接口，这些地址称为单播地址。除了单播地址，其他类型的地址包括广播、组播和任播地址，它们可能涉及多个接口，还有一些特殊用途的地址。而我们主要围绕讨论的是单播地址 广播地址 ，如果发送这个地址，所有10.11.12 网络里面的设备都可以收到 网络号， 子网掩码和IP按位与就可得到网络号 IP地址的主机号 ​ 全0：表示整个子网 ​ 全1：表示向子网上所有设备发送包，即“广播” IP怎么来的如何配置IP地址？ 往往我们上网不会为了IP而担忧，打开wifi，IP就自动设置好了。 其实就是使用默认的DHCP ##### 第一个协议 DHCP(Dynamic Host Configuration Protocol) 动态主机配置协议， 一个自动配置的协议有了这个协议，网络管理员就轻松多了。他只需要配置一段共享的 IP 地址。每一台新接入的机器都通过 DHCP 协议，来这个共享的 IP 地址里申请，然后自动配置好就可以了。等人走了，或者用完了，还回去，这样其他的机器也能用 DHCP 的方式就相当于租房。你不用装修，都是帮你配置好的。你暂时用一下，用完退租就可以了 #####解析 DHCP 的工作方式 1.DHCP Discover 新来的机器使用 IP 地址 0.0.0.0 发送了一个广播包，目的 IP 地址为 255.255.255.255。广播包封装了 UDP，UDP 封装了 BOOTP。其实 DHCP 是 BOOTP 的增强版 Boot request 我的 MAC 地址是这个，我还没有 IP，谁能给租给我个 IP 地址！ DHCP Offer ip DHCP Request ip ACK Socket库提供查询IP地址的功能 询问 DNS 服务器 获取IP ，端口号 Socket 存有 描述符，IP，端口号 通过“描述符”来识别socket 还没有MAC地址 ARP 通过IP找MAC 同网段广播 套接字的实体就是通信控制信息 协议栈是根据套接字中记录的控制信息来工作的。 连接是什么意思 连接实际上是通信双方交换控制信息 收据收发 数据小 首先，协议栈并不关心应用程序传来的数据是什么内容。应用程序在 调用 write 时会指定发送数据的长度，在协议栈看来，要发送的数据就是 一定长度的二进制字节序列而已。 其次，协议栈并不是一收到数据就马上发送出去，而是会将数据存放在内部的发送缓冲区中，并等待应用程序的下一段数据。这样做是有道理的。应用程序交给协议栈发送的数据长度是由应用程序本身来决定的，不同的应用程序在实现上有所不同，有些程序会一次性传递所有的数据，有些程序则会逐字节或者逐行传递数据。总之，一次将多少数据交给协议栈是由应用程序自行决定的，协议栈并不能控制这一行为。在这样的情况下，如果一收到数据就马上发送出去，就可能会发送大量的小包，导致网络效率下降，因此需要在数据积累到一定量时再发送出去。至于要积累多少数据才能发送，不同种类和版本的操作系统会有所不同，不能一概而论，但都是根据下面几个要素来判断的。 第一个判断要素是每个网络包能容纳的数据长度，协议栈会根据一个 叫作MTU的参数来进行判断。MTU 表示一个网络包的最大长度，在以太网中一般是 1500 字节。MTU 是包含头部的总长度，因此需要从MTU 减去头部的长度，然后得到的长度就是一个网络包中所能容纳的最大数据长度，这一长度叫作 MSS。当从应用程序收到的数据长度超过或者接近 MSS 时再发送出去，就可以避免发送大量小包的问题了。 另一个判断要素是时间。当应用程序发送数据的频率不高的时候，如果每次都等到长度接近 MSS 时再发送，可能会因为等待时间太长而造成发送延迟，这种情况下，即便缓冲区中的数据长度没有达到 MSS，也应该果 断发送出去。为此，协议栈的内部有一个计时器，当经过一定时间之后，就会把网络包发送出去 A。 判断要素就是这两个，但它们其实是互相矛盾的。如果长度优先，那么网络的效率会提高，但可能会因为等待填满缓冲区而产生延迟;相反地，如果时间优先，那么延迟时间会变少，但又会降低网络的效率。因此，在进行发送操作时需要综合考虑这两个要素以达到平衡。不过，TCP 协议规 格中并没有告诉我们怎样才能平衡，因此实际如何判断是由协议栈的开发者来决定的，也正是由于这个原因，不同种类和版本的操作系统在相关操 作上也就存在差异。 正如前面所说，如果仅靠协议栈来判断发送的时机可能会带来一些问 题，因此协议栈也给应用程序保留了控制发送时机的余地。应用程序在发送数据时可以指定一些选项，比如如果指定“不等待填满缓冲区直接发送”，则协议栈就会按照要求直接发送数据。像浏览器这种会话型的应用程 序在向服务器发送数据时，等待填满缓冲区导致延迟会产生很大影响，因 此一般会使用直接发送的选项。 MTU:Maximum Transmission Unit:一个网络包的最大长度，以太网中一般为1500字节。 MSS:Maximum Segment Size:除去头部之后，一个网络包所能容纳的TCP数据的最大长度。 最大分段大小。 TCP 和 IP 的头部加起来一般是 40 字节，因此 MTU 减去这个长度就是 MSS。例如，在以太网中， MTU 为 1500，因此 MSS 就是 1460。TCP/IP 可以使用一些可选参数 (protocol option)，如加密等，这时头部的长度会增加，那么 MSS 就会随着头部长度增加而相应缩短。 数据大 滑动窗口 所谓滑动窗口，就是在发送一 个包之后，不等待 ACK 号返回，而是直接发送后续的一系列包。 TCP整体流程 UDP 作为iOS出身，深受那一代人影响。所以第一个抓包工具使用的是Charles 俗称青花瓷，有免费版本，不过会定时的弹框。受限于中间人抓包法，注定无法捕获全部的包。 抓包神器 Wireshark参考资料 https://en.wikipedia.org/wiki/Private_network","categories":[],"tags":[{"name":"Internet, http","slug":"Internet-http","permalink":"onegoon.store/tags/Internet-http/"}]},{"title":"Swift Packages","slug":"Swift-Packages","date":"2020-03-08T14:29:13.000Z","updated":"2020-03-11T16:13:23.570Z","comments":true,"path":"2020/03/08/Swift-Packages/","link":"","permalink":"onegoon.store/2020/03/08/Swift-Packages/","excerpt":"苹果官方的包管理工具","text":"苹果官方的包管理工具","categories":[],"tags":[{"name":"swift","slug":"swift","permalink":"onegoon.store/tags/swift/"}]},{"title":"cocoapods","slug":"cocoapods","date":"2020-03-08T14:09:05.000Z","updated":"2020-03-11T16:12:22.746Z","comments":true,"path":"2020/03/08/cocoapods/","link":"","permalink":"onegoon.store/2020/03/08/cocoapods/","excerpt":"What is CocoaPodsCocoaPods manages library dependencies for your Xcode projects. The dependencies for your projects are specified in a single text file called a Podfile. CocoaPods will resolve dependencies between libraries, fetch the resulting source code, then link it together in an Xcode workspace to build your project. Ultimately the goal is to improve discoverability of, and engagement in, third party open-source libraries by creating a more centralised ecosystem.","text":"What is CocoaPodsCocoaPods manages library dependencies for your Xcode projects. The dependencies for your projects are specified in a single text file called a Podfile. CocoaPods will resolve dependencies between libraries, fetch the resulting source code, then link it together in an Xcode workspace to build your project. Ultimately the goal is to improve discoverability of, and engagement in, third party open-source libraries by creating a more centralised ecosystem. iOS 开发的依赖管理工具 cocoapods 的作用 Project GoalsCocoaPods aims to improve the engagement with, and discoverability of, third party open-source Cocoa libraries. These project goals influence and drive the design of CocoaPods: Create and share libraries, and use them in your own projects, without creating extra work for library authors. Integrate non-CocoaPods libraries and hack on your own fork of any CocoaPods library with a simple transparent Podspec standard. Allow library authors to structure their libraries however they like. Save time for library authors by automating a lot of Xcode work not related to their libraries’ functionality. Support any source management system. (Currently supported are git, svn, mercurial, bazaar, and various types of archives downloaded over HTTP.) Promote a culture of distributed collaboration on pods, but also provide features only possible with a centralised solution to foster a community. Build tools on top of the core Cocoa development system, including those typically deployed to other operating systems, such as web-services. Provide opinionated and automated integration, but make it completely optional. You may manually integrate your CocoaPods dependencies into your Xcode project as you see fit, with or without a workspace. Solve everyday problems for Cocoa and Xcode developers. 解决的痛点 自动集成，便于管理，解决了手动集成的弊端，如代码更新难以维护 依赖相互依赖递归依赖 各个库依赖的版本不同问题 查看细节 –verbose1234pod install --verbose# 不更新本地库 比如本地缓存有AFN2.0就不会自动更新到3.0# [-v | --verbose]pod install --verbose --no-repo-update Podfile.lock （记录install的文件，不只是pod install）这是 CocoaPods 创建的最重要的文件之一。它记录了需要被安装的 pod 的每个已安装的版本。如果你想知道已安装的 pod 是哪个版本，可以查看这个文件。推荐将 Podfile.lock 文件加入到版本控制中，这有助于整个团队的一致性。 第一次pod install会创建.lock文件，之后pod install（如果Podfile没改变）则不会改动.lock文件 而执行pod update 则会强行按照Podfile文件进行拉取依赖文件，并更新.lock文件。这样看来如果执行update指令还是有风险的 Manifest.lock （为了校验Pods里的文件与Podfile.lock记录是否一致）这是每次运行 pod install 命令时创建的 Podfile.lock 文件的副本。如果你遇见过这样的错误 沙盒文件与 Podfile.lock 文件不同步 (The sandbox is not in sync with the Podfile.lock)，这是因为 Manifest.lock 文件和 Podfile.lock 文件不一致所引起。由于 Pods 所在的目录并不总在版本控制之下，这样可以保证开发者运行 app 之前都能更新他们的 pods，否则 app 可能会 crash，或者在一些不太明显的地方编译失败。 日常工作中是否应把pod相关文件加到版本控制中Pods文件夹不要加 Podfile 要加 Podfile.lock 要加到版本控制中 假设我们在 Podfile 中写上: pod &#39;AFNetWorking&#39;，那么默认是安装 AFNetworking 的最新代码。这就导致用户 A 可能装的是 3.0 版本，而用户 B 再安装就变成了 4.0 版本。即使我们在 Podfile 中指定了库的具体版本，那也不能保证不出问题。因为一个第三方库还有可能依赖其他的第三方库，而且不保证它的依赖关系是具体到版本号的。 因此 Podfile.lock 存在的意义是将某一次 pod install 时使用的各个库的版本，以及这个库依赖的其他第三方库的版本记录下来，以供别人使用。 这样一来，pod install 的流程其实是: 判断 Podfile.lock 是否存在，如果不存在，按照 Podfile 中指定的版本安装 如果 Podfile.lock 存在，检查 Podfile 中每一个 Pod 在 Podfile.lock 中是否存在 如果存在， 则忽略 Podfile 中的配置，使用 Podfile.lock 中的配置(实际上就是什么都不做) 如果不存在，则使用 Podfile 中的配置，并写入 Podfile.lock 中 而另一个常用命令 pod update 并不是一个日常更新命令。它的原理是忽略 Podfile.lock 文件，完全使用 Podfile 中的配置，并且更新 Podfile.lock。一旦决定使用 pod update，就必须所有团队成员一起更新。因此在使用 update 前请务必了解其背后发生的事情和对团队造成的影响，并且确保有必要这么做。 参考cocoapods objccn.io 上的期刊《深入理解CocoaPods》 张星宇的博客","categories":[],"tags":[{"name":"CocoaPods","slug":"CocoaPods","permalink":"onegoon.store/tags/CocoaPods/"}]},{"title":"terminal经验 ","slug":"terminal经验","date":"2020-03-07T05:59:05.000Z","updated":"2020-03-19T02:14:57.333Z","comments":true,"path":"2020/03/07/terminal经验/","link":"","permalink":"onegoon.store/2020/03/07/terminal经验/","excerpt":"操作文件跟常见的两种 1234# Mac（硬盘）的根/# 用户的根~ 比如你当前处于 ~目录下。执行pwd，得到/Users/用户名 变更目录 (change directory)123456789# 跳转到上层路径 比如当前路径 ~/a/b -&gt; ~/acd .. # 跳转到上两层cd ...# （用户）当前用户的根目录 比如我的电脑用户名alan， /Users/alancd ~cd --# 跳转到上一次所在的路径cd -","text":"操作文件跟常见的两种 1234# Mac（硬盘）的根/# 用户的根~ 比如你当前处于 ~目录下。执行pwd，得到/Users/用户名 变更目录 (change directory)123456789# 跳转到上层路径 比如当前路径 ~/a/b -&gt; ~/acd .. # 跳转到上两层cd ...# （用户）当前用户的根目录 比如我的电脑用户名alan， /Users/alancd ~cd --# 跳转到上一次所在的路径cd - 创建文件1234# 创建文件夹mkdir# 创建文件touch 查看文件123456789101112# 查看文件内容cat # 查看当前路径pwd# 当前文件列表ls# ls /bin# 显示隐藏文件ls -a # 详细信息，主要可以看文件权限ls -l 复制文件12# 将a复制到bcp a b 删除文件123456# 删除空文件夹rmdir # 删除文件 -r递归删除rm -r &lt;filePath&gt;# 删除文件 -f强行删除rm -rf &lt;filePath&gt; 移动文件12# 移动文件 a -&gt; bmv a b 打开文件12# 国际通用helpopen --help 12# 打开文件（默认程序打开）open &lt;fileName&gt; 12# 使用特定app打开特定文件open -a &lt;appUrl&gt; &lt;fileName&gt; ​ 文件内查找123grep# 比如可以配合lsls | grep &lt;filter&gt; 当前正在运行的进程 123ps# 查看正在运行进程的可执行文件路径ps -e","categories":[],"tags":[{"name":"terminal","slug":"terminal","permalink":"onegoon.store/tags/terminal/"}]},{"title":"git经验","slug":"git经验","date":"2020-03-07T05:57:26.000Z","updated":"2020-03-14T14:59:46.793Z","comments":true,"path":"2020/03/07/git经验/","link":"","permalink":"onegoon.store/2020/03/07/git经验/","excerpt":"","text":"撤销git reset通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”。向上移动分支，原来指向的提交记录就跟重来没有提交过一样。 git revert两者的区别reset意义 ：回到指定节点（哈希值或者相对引用） 表象：清理结点，这个节点之后记录的统统不要了，真正做到回到过去。 revert意义：撤销指定结点的操作 表象：提交一新个记录，该次提交的作用为上一步的逆操作，工作树上表现为新增一个结点 总结得到的结果是一样的，但是在work tree 上表现不同， reset为不留痕迹 revert保留完整的操作记录 查看log以图表形式查看分支git log --graph 只显示第一行git log --pretty=short 只显示指定文件的日志git log &lt;filename&gt; 显示文件的改动git log -p git log -p &lt;filename&gt; 查看更改前后的差别git diff 分支git checkout -b &lt;branchname&gt; 提交 添加与提交一起完成 git commit -a -m","categories":[],"tags":[{"name":"git","slug":"git","permalink":"onegoon.store/tags/git/"}]},{"title":"Terminal command","slug":"Terminal-command","date":"2020-03-05T10:34:08.000Z","updated":"2020-03-05T10:47:31.954Z","comments":true,"path":"2020/03/05/Terminal-command/","link":"","permalink":"onegoon.store/2020/03/05/Terminal-command/","excerpt":"","text":"iOS 13 以来， 手机内存吃紧，UI上显示还空余5个多G，可是Xcode上却显示只剩下一个多G，该信谁的 开发也有过一些难以想象的苹果的bug，Xcode编译程序导致访问 nib 文件必现crash 最近又发现 Mac (Mojave 10.14.6) 上的文件系统，更新文件增加文件当前Finder界面并不会立刻更新，而是需要来回切换才会显示，有时即使这样也不会显示新增的文件。 不得不使用命令来操作文件了 也有可能是我的15年的老古董支撑不起强大的操作系统了 作为程序员，本不应该依赖UI界面的，正好借此开始逐渐脱离图形界面操作 希望这些只是苹果在创新尝试的小纰漏，也希望苹果能有更多的进步创新。","categories":[],"tags":[]},{"title":"Django Restful","slug":"Django-Restful","date":"2020-03-04T03:35:33.000Z","updated":"2020-03-04T07:46:05.445Z","comments":true,"path":"2020/03/04/Django-Restful/","link":"","permalink":"onegoon.store/2020/03/04/Django-Restful/","excerpt":"","text":"python 搭建rest API有两大主流 Django 与 Flask Django 较重 组件齐全 Flask 较轻，灵活 我选择先入手Django，原因是生态。 后续有能力还会在来Flask RESTRepresentational state transfer 表现层状态转换 Roy Thomas Fielding博士提出的一种网络服务架构的风格。也叫restful。 表现层状态转换是基于超文本传输协议之上的一族约束和属性，是一种设计网络服务的软件构建风格。 客户端发出请求以统一资源标识符访问和操作网络资源 当前在三种主流的Web服务实现方案中，因为REST模式与复杂的SOAP和XML-RPC相比更加简洁，越来越多的Web服务开始采用REST风格设计和实现。 Django rest 框架 django-rest-framework 官方文档 https://www.django-rest-framework.org/","categories":[],"tags":[]},{"title":"SQL","slug":"SQL","date":"2020-03-03T10:35:43.000Z","updated":"2020-03-03T14:25:37.665Z","comments":true,"path":"2020/03/03/SQL/","link":"","permalink":"onegoon.store/2020/03/03/SQL/","excerpt":"","text":"MYSQL安装 mysql下载：https://dev.mysql.com/downloads/ navicat下载：https://www.navicat.com.cn/ 出现个问题 .bash_profile 添加路径 但是在terminal上无效，还需要手动 设置PATH PATH=${PATH}:/usr/local/mysql/bin mysql -u root -p -u 代表user 这里用户名为root -p password 使用MYSQL的图形化程序navicat","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"onegoon.store/tags/SQL/"}]},{"title":"有一个想法","slug":"有一个想法","date":"2020-03-02T12:25:17.000Z","updated":"2020-03-12T07:52:33.430Z","comments":true,"path":"2020/03/02/有一个想法/","link":"","permalink":"onegoon.store/2020/03/02/有一个想法/","excerpt":"","text":"有一个想法。 想搭建一个平台，后端到前端产品到UI 本来想先用iOS native 现行，奈何我这15年的老古董已经带不动Xcode了，毕竟在家的时间是自己的能省则省，打算改用flutter了。","categories":[],"tags":[{"name":"架构","slug":"架构","permalink":"onegoon.store/tags/架构/"}]},{"title":"Django入门","slug":"Django入门","date":"2020-02-28T02:39:28.000Z","updated":"2020-03-11T16:12:39.802Z","comments":true,"path":"2020/02/28/Django入门/","link":"","permalink":"onegoon.store/2020/02/28/Django入门/","excerpt":"","text":"Django 初级篇虚拟环境 virtualenv1virtualenv venv -p python3 为project提供独立的python环境。pycharm默认开启的 开启 1source venv/bin/activate 开启后 命令行最左端有(venv)字样 代表虚拟环境开启 1(venv) ➜ PlanA 注意开启后 所有操作都在venv环境下进行的 使用 python 而不是python3，pip而不是pip3 关闭 1deactivate 安装 Djangoinstall django ```12345678就此环境搭建完毕##### 开始构建项目（Project）我的第一个项目`PlanA````django-admin startproject PlanA 12345678910PlanA/ &lt;-- higher level folder├── PlanA &lt;-- django project folder （ `startproject` 命令创建的）│ ├── PlanA│ │ ├── __init__.py│ │ ├── asgi.py│ │ ├── settings.py│ │ ├── urls.py│ │ └── wsgi.py│ └── manage.py└── venv &lt;-- virtual environment folder 这些目录和文件的用处是：(django 文档给出) The outer mysite/ root directory is a container for your project. Its name doesn’t matter to Django; you can rename it to anything you like. manage.py: 一个让你用各种方式管理 Django 项目的命令行工具。你可以阅读 django-admin and manage.py 获取所有 manage.py 的细节。 里面一层的 mysite/ 目录包含你的项目，它是一个纯 Python 包。它的名字就是当你引用它内部任何东西时需要用到的 Python 包名。 (比如 mysite.urls). mysite/__init__.py：一个空文件，告诉 Python 这个目录应该被认为是一个 Python 包。如果你是 Python 初学者，阅读官方文档中的 更多关于包的知识。 mysite/settings.py：Django 项目的配置文件。如果你想知道这个文件是如何工作的，请查看 Django 配置 了解细节。 mysite/urls.py：Django 项目的 URL 声明，就像你网站的“目录”。阅读 URL调度器 文档来获取更多关于 URL 的内容。 mysite/asgi.py: An entry-point for ASGI-compatible web servers to serve your project. See How to deploy with ASGI for more details. mysite/wsgi.py：作为你的项目的运行在 WSGI 兼容的Web服务器上的入口。阅读 如何使用 WSGI 进行部署 了解更多细节。 一个project可以包含很多个app 同一个app可以存在与多个project中 创建appstartapp boards ```123456789101112注意这次我们用的是`startapp`.├── __init__.py├── admin.py├── apps.py├── migrations│ └── __init__.py├── models.py├── tests.py└── views.py PlanA/ &lt;– higher level folder├── boards &lt;– our new django app!│ ├── init.py│ ├── admin.py│ ├── apps.py│ ├── migrations│ │ └── init.py│ ├── models.py│ ├── tests.py│ └── views.py├── PlanA &lt;– django project folder （ startproject 命令创建的）│ ├── PlanA│ │ ├── init.py│ │ ├── asgi.py│ │ ├── settings.py│ │ ├── urls.py│ │ └── wsgi.py│ └── manage.py└── venv &lt;– virtual environment folder 123456##### 本地运行服务 8000端口``` python manage.py runserver 更换端口默认情况下，runserver 命令会将服务器设置为监听本机内部 IP 的 8000 端口。 如果你想更换服务器的监听端口，请使用命令行参数。举个例子，下面的命令会使服务器监听 8080 端口： 1$ python manage.py runserver 8080 如果你想要修改服务器监听的IP，在端口之前输入新的。比如，为了监听所有服务器的公开IP（这你运行 Vagrant 或想要向网络上的其它电脑展示你的成果时很有用），使用： 1$ python manage.py runserver 0:8000 0 是 0.0.0.0 的简写。完整的关于开发服务器的文档可以在 :djamdin:runserver 参考文档中找到。 新版django 的路由 path与re_path1234urlpatterns = [ path(&apos;polls/&apos;, include(&apos;polls.urls&apos;)), path(&apos;admin/&apos;, admin.site.urls),] 以前是url path() 参数： route¶route 是一个匹配 URL 的准则（类似正则表达式）。当 Django 响应一个请求时，它会从 urlpatterns 的第一项开始，按顺序依次匹配列表中的项，直到找到匹配的项。 这些准则不会匹配 GET 和 POST 参数或域名。例如，URLconf 在处理请求 https://www.example.com/myapp/ 时，它会尝试匹配 myapp/ 。处理请求 https://www.example.com/myapp/?page=3 时，也只会尝试匹配 myapp/。 path() 参数： view¶当 Django 找到了一个匹配的准则，就会调用这个特定的视图函数，并传入一个 HttpRequest 对象作为第一个参数，被“捕获”的参数以关键字参数的形式传入。稍后，我们会给出一个例子。 path() 参数： kwargs¶任意个关键字参数可以作为一个字典传递给目标视图函数。本教程中不会使用这一特性。 path() 参数： name¶为你的 URL 取名能使你在 Django 的任意地方唯一地引用它，尤其是在模板中。这个有用的特性允许你只改一个文件就能全局地修改某个 URL 模式。 当你了解了基本的请求和响应流程后，请阅读 教程的第 2 部分 开始使用数据库. 数据库迁移manage.py makemigrations```12```python manage.py migrate 资料https://tutorial.djangogirls.org/zh/ 一个gitbook，难度较低的教程，如果有基础不建议看 https://github.com/TwoWater/Python 国人写的教程，能够快速了解陌生的信息 https://docs.djangoproject.com/ 官方文档，更新较为即时，语言可选中文。 https://simpleisbetterthancomplex.com/series/beginners-guide/1.11/ 新人友善的博客，带你一步一步完成一个论坛类的project 17年写的有些东西需要更新。","categories":[],"tags":[{"name":"python, django","slug":"python-django","permalink":"onegoon.store/tags/python-django/"}]},{"title":"19年总结","slug":"19年总结","date":"2019-12-31T15:22:21.000Z","updated":"2020-03-11T16:14:21.697Z","comments":true,"path":"2019/12/31/19年总结/","link":"","permalink":"onegoon.store/2019/12/31/19年总结/","excerpt":"工作上技术长进学会了如何团队开发","text":"工作上技术长进学会了如何团队开发 iOS的技能点 点的比较多 ​ 单元测试写了不少，对单元测试有了另一番的理解感悟，code容易片面，test来补全 ​ Swift 较为精进毕竟日常开发，编译了Swift并阅读了部分源码，如网络部分，json解析，数据结构部分等 ​ Darwin-xnu, pthread, dyld, Foundation.混个面熟吧。 ​ 从头跟了MonkeyDev的逆向，会使用逆向工具，更加了解了iOS&amp;macOS的运行机制， ​ 对MachO的解析也实践了一段，配合阅读《程序员的自我修养》《深入理解计算系统》。 ​ 汇编，要想理解、验证一些底层的东西还是绕不开汇编的。但是Risc实在太精简了 数据结构与算法，多数的还处于思想上。能手写的只有那几个排序，，base huffman实现了一个解压缩算法 操作系统也学了些，了解CPU的一些机制流水线，多发射，超标量，分支预测，多核协作等。 网络 组内分享了一次TCP/IP，继续阅读POSIX的源码，目前仅完成了用户态 socket的demo，其实还是在应用层。后续要深入到内核态看看。 Wireshark真是个好东西，大家能看到的才有说服力。 生活上程序员离开了电脑如丧失了大脑，编码之外的其他人情世故似乎不差了不少。（也仅可能是我吧，个人感受）。 跑了不少次医院，对医院的流程，对世故的处理有所感悟 篮球，年龄将长，身体越发虚弱~~··。适当锻炼，身体倍棒，远离CS 马上要见家长了，紧张","categories":[],"tags":[]},{"title":"mac socket","slug":"mac-socket","date":"2019-12-27T08:14:01.000Z","updated":"2020-03-11T16:13:11.540Z","comments":true,"path":"2019/12/27/mac-socket/","link":"","permalink":"onegoon.store/2019/12/27/mac-socket/","excerpt":"### 套接字接口的起源 套接字接口是加州大学伯克利分校的研究员在20世纪80年代早期提出来的。因为这个原因，它也常被叫做伯克利套接字。伯克利的研究者使得套接字接口适用于任何底层的协议。第一个实现的就是针对TCP/IP协议的，他们把它包括在Unix 4.2BSD的内核里，并且分发给许多学校和实验室。这在因特网的历史上是一个重大事件。几乎一夜之间，成千上万的人们接触到了TCP/IP和它的源代码。它引起了巨大的轰动，并激发了新的网络和网络互联研究的浪潮 节选自 《深入理解计算机系统》第三版 伯克利 Berkeley Core Foundation通过CFNetwork提供了封装套接字的CFSocket和CFStream，此外还进一步提供了一些协议的封装，例如CFFTP、CFHTTP等 BSD套接字是XNU中所有网络组件的核心","text":"### 套接字接口的起源 套接字接口是加州大学伯克利分校的研究员在20世纪80年代早期提出来的。因为这个原因，它也常被叫做伯克利套接字。伯克利的研究者使得套接字接口适用于任何底层的协议。第一个实现的就是针对TCP/IP协议的，他们把它包括在Unix 4.2BSD的内核里，并且分发给许多学校和实验室。这在因特网的历史上是一个重大事件。几乎一夜之间，成千上万的人们接触到了TCP/IP和它的源代码。它引起了巨大的轰动，并激发了新的网络和网络互联研究的浪潮 节选自 《深入理解计算机系统》第三版 伯克利 Berkeley Core Foundation通过CFNetwork提供了封装套接字的CFSocket和CFStream，此外还进一步提供了一些协议的封装，例如CFFTP、CFHTTP等 BSD套接字是XNU中所有网络组件的核心 socket 函数客户端和服务器使用socket函数来创建一个套接字描述符 在&lt;sys/socket.h&gt;中定义int socket(int, int, int); 在bsd&gt;kern&gt;syscalls.master 中97 AUE_SOCKET ALL { int socket(int domain, int type, int protocol); } 若成功则为非负描述符，若出错则为-1 12345678910/** domain 套接字域（地址/协议族）通常指的是 AF（Address Family）或者PF(Protocol Family)表示第2层或第3层地址对应的套接字地址模式。常见的IP协议，即PF_INET或AF_INET传统上使用的是AF_*常量，PF_*常量只不过是通过AF_*常量#define得到的* type * protocol 所在文件bsd &gt; netinet &gt; in.h Xcode里面也能看见注释*/int socket(int domain, int type, int protocol) 1234567891011// socket.h 114~123/* * Types */#define SOCK_STREAM 1 /* stream socket */#define SOCK_DGRAM 2 /* datagram socket */#define SOCK_RAW 3 /* raw-protocol interface */#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)#define SOCK_RDM 4 /* reliably-delivered message */#endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */#define SOCK_SEQPACKET 5 /* sequenced packet stream */ 123456789101112131415// socket.h 528~586/* * Address families. */#define AF_UNSPEC 0 /* unspecified */#define AF_UNIX 1 /* local to host (pipes) */#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)#define AF_LOCAL AF_UNIX /* backward compatibility */#endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */#define AF_INET 2 /* internetwork: UDP, TCP, etc. */...#define AF_INET6 30 /* IPv6 */... 1234567891011// socket.h 632~680/* * Protocol families, same as address families for now. */#define PF_UNSPEC AF_UNSPEC#define PF_LOCAL AF_LOCAL#define PF_UNIX PF_LOCAL /* backward compatibility */#define PF_INET AF_INET...#define PF_INET6 AF_INET6...","categories":[],"tags":[{"name":"socket","slug":"socket","permalink":"onegoon.store/tags/socket/"}]},{"title":"Mac app socket server","slug":"Mac-app-socket-server","date":"2019-12-26T08:24:57.000Z","updated":"2019-12-27T01:24:50.949Z","comments":true,"path":"2019/12/26/Mac-app-socket-server/","link":"","permalink":"onegoon.store/2019/12/26/Mac-app-socket-server/","excerpt":"在macOS app 上创建socket server 发现创建失败 抛出异常代码如下 1try checkNotMinus1&#123; Darwin.bind(ipv4Socket, addrPtr, UInt32(MemoryLayout&lt;sockaddr_in&gt;.size)) 123456789/// 封装检测是否为-1/// errno 为Darwin的错误码enum SocketError: Error &#123; case socketCreateFailed(Int32) &#125;@discardableResultfunc checkNotMinus1(_ f: () -&gt; Int32) throws -&gt; Int32 &#123; let r = f() guard r != -1 else &#123; throw SocketError.socketCreateFailed(errno) &#125; return r&#125; catch中的error 为ssocketCreateFailed(1) 也就是errno为1","text":"在macOS app 上创建socket server 发现创建失败 抛出异常代码如下 1try checkNotMinus1&#123; Darwin.bind(ipv4Socket, addrPtr, UInt32(MemoryLayout&lt;sockaddr_in&gt;.size)) 123456789/// 封装检测是否为-1/// errno 为Darwin的错误码enum SocketError: Error &#123; case socketCreateFailed(Int32) &#125;@discardableResultfunc checkNotMinus1(_ f: () -&gt; Int32) throws -&gt; Int32 &#123; let r = f() guard r != -1 else &#123; throw SocketError.socketCreateFailed(errno) &#125; return r&#125; catch中的error 为ssocketCreateFailed(1) 也就是errno为1 ⌘左键 进入代码定义（Jump to Definition） 发现只有定义没有注释，能看到他是定义在Darwin中 打开Darwin-xnu 找到errno.h (&lt;sys/errno.h&gt;) 发现错误码为1 对应 Operation not permitted 我是使用Xcode的版本 Version 11.2.1 (11B500) 新版Xcode会把app 的能力单独一页列出来 当我勾选Network 的 Server选项后 bind成功了","categories":[],"tags":[{"name":"Mac OS","slug":"Mac-OS","permalink":"onegoon.store/tags/Mac-OS/"}]},{"title":"SF Symbols","slug":"SF-Symbols","date":"2019-12-26T05:06:06.000Z","updated":"2019-12-26T05:56:36.424Z","comments":true,"path":"2019/12/26/SF-Symbols/","link":"","permalink":"onegoon.store/2019/12/26/SF-Symbols/","excerpt":"SF Symbols Mac上的一款app 有超1500个符号可供使用，也可以自定义符号 可以导出文件，用sketch编辑","text":"SF Symbols Mac上的一款app 有超1500个符号可供使用，也可以自定义符号 可以导出文件，用sketch编辑 UIKit 提供了两种API，一种是使用系统符号，另外一种是自定义 init(systemName:) init(systemName:compatibleWith:) init(systemName:withConfiguration:)methods of UIImage. init(named:) init(named:in:compatibleWith:) init(named:in:with:) 1let image = UIImage(systemName: \"square.and.arrow.up\") image 会加载对应的符号 也可以自定义符号 Assets.xcassets / + / New Symbol Image Set / 拖拽编辑好的SVG文件到xcode中 效果如图 1let image = UIImage(systemName: \"arrowupfill\") #####link refer Creating Custom Symbol Images for Your App","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"onegoon.store/tags/iOS/"}]},{"title":"iOS URLSession Request","slug":"iOS-URLSession-Request","date":"2019-11-27T15:14:13.000Z","updated":"2019-11-27T16:22:22.736Z","comments":true,"path":"2019/11/27/iOS-URLSession-Request/","link":"","permalink":"onegoon.store/2019/11/27/iOS-URLSession-Request/","excerpt":"概览","text":"概览 参考资料 Foundation","categories":[],"tags":[]},{"title":"抓包","slug":"抓包","date":"2019-10-01T07:25:18.000Z","updated":"2020-03-11T16:13:47.509Z","comments":true,"path":"2019/10/01/抓包/","link":"","permalink":"onegoon.store/2019/10/01/抓包/","excerpt":"网络已成为当下人类的必需品，身为开发人员势必了解其原理，无论是正向开发，抑或是逆向攻击。 网络抓包，是对网络传输中的数据包进行抓取。而后可对其进行分析。 正向开发中，我们可以通过抓包进行验证发送的数据是否正确，如验证发送的次数，host，path，header等。 也可以对特定的请求模拟给出特定的响应结果，检查发送端在得到响应后的行为是否符合预期，比如验证一些业务场景极少发生的场景以及边界等。","text":"网络已成为当下人类的必需品，身为开发人员势必了解其原理，无论是正向开发，抑或是逆向攻击。 网络抓包，是对网络传输中的数据包进行抓取。而后可对其进行分析。 正向开发中，我们可以通过抓包进行验证发送的数据是否正确，如验证发送的次数，host，path，header等。 也可以对特定的请求模拟给出特定的响应结果，检查发送端在得到响应后的行为是否符合预期，比如验证一些业务场景极少发生的场景以及边界等。 抓包工具Charles (青花瓷/花瓶)Charles 支持截取 HTTP/HTTPS Charles 抓包原理是将自己设为代理。 代理相当于一个中间人 ​ 客户端发送的所有数据都会先通过代理，然后由代理发送给服务器。 ​ 服务器收到请求后，将相应消息返回给代理，然后由代理发送给客户端。 对客户端来说代理就是服务器，对服务器来说代理就是客户端，所以两者都不会感知网络被拦截了。这就是中间人攻击的原理。 拦截iPhone上的网络请求 将Charles的代理功能打开 设置代理并勾选”Enable transparent HTTP proxying” 查看ip， Help -&gt; Local IP Address . 或者去网络设置中去查看，如今可以看到两种地址，短的是IPv4,长的是IPv6. 在iphone上，设置网络代理为Charles启动的代理服务器。","categories":[],"tags":[{"name":"http","slug":"http","permalink":"onegoon.store/tags/http/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-05-28T14:39:18.000Z","updated":"2019-05-28T14:39:18.000Z","comments":true,"path":"2019/05/28/hello-world/","link":"","permalink":"onegoon.store/2019/05/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}