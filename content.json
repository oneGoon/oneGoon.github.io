{"meta":{"title":"WG's Lakeside","subtitle":"只是想显点粗浅技艺，那是我的初衷","description":null,"author":"Ticat","url":"onegoon.store","root":"/"},"pages":[],"posts":[{"title":"terminal经验 ","slug":"terminal经验","date":"2020-03-07T05:59:05.000Z","updated":"2020-03-07T07:21:21.586Z","comments":true,"path":"2020/03/07/terminal经验/","link":"","permalink":"onegoon.store/2020/03/07/terminal经验/","excerpt":"","text":"操作文件变更目录 (change directory)123456789# 跳转到上层路径 比如当前路径 ~/a/b -&gt; ~/acd .. # 跳转到上两层cd ...# （用户）当前用户的根目录 比如我的电脑用户名alan， /Users/alancd ~cd --# 跳转到上一次所在的路径cd - 创建文件1234# 创建文件夹mkdir# 创建文件touch 查看文件123456789101112# 查看文件内容cat # 查看当前路径pwd# 当前文件列表ls# ls /bin# 显示隐藏文件ls -a # 详细信息，主要可以看文件权限ls -l 复制文件12# 将a复制到bcp a b 删除文件123456# 删除空文件夹rmdir # 删除文件 -r递归删除rm -r &lt;filePath&gt;# 删除文件 -f强行删除rm -rf &lt;filePath&gt; 移动文件12# 移动文件 a -&gt; bmv a b 打开文件12# 国际通用helpopen --help 12# 打开文件（默认程序打开）open &lt;fileName&gt; 12# 使用特定app打开特定文件open -a &lt;appUrl&gt; &lt;fileName&gt; ​ 文件内查找123grep# 比如可以配合lsls | grep &lt;filter&gt;","categories":[],"tags":[{"name":"terminal","slug":"terminal","permalink":"onegoon.store/tags/terminal/"}]},{"title":"git经验","slug":"git经验","date":"2020-03-07T05:57:26.000Z","updated":"2020-03-07T10:21:40.846Z","comments":true,"path":"2020/03/07/git经验/","link":"","permalink":"onegoon.store/2020/03/07/git经验/","excerpt":"","text":"git checkout -b 撤销git reset通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”。向上移动分支，原来指向的提交记录就跟重来没有提交过一样。 git revert两者的区别reset意义 ：回到指定节点（哈希值或者相对引用） 表象：清理结点，这个节点之后记录的统统不要了，真正做到回到过去。 revert意义：撤销指定结点的操作 表象：提交一新个记录，该次提交的作用为上一步的逆操作，工作树上表现为新增一个结点 总结得到的结果是一样的，但是在work tree 上表现不同， reset为不留痕迹 revert保留完整的操作记录","categories":[],"tags":[{"name":"git","slug":"git","permalink":"onegoon.store/tags/git/"}]},{"title":"Terminal command","slug":"Terminal-command","date":"2020-03-05T10:34:08.000Z","updated":"2020-03-05T10:47:31.954Z","comments":true,"path":"2020/03/05/Terminal-command/","link":"","permalink":"onegoon.store/2020/03/05/Terminal-command/","excerpt":"","text":"iOS 13 以来， 手机内存吃紧，UI上显示还空余5个多G，可是Xcode上却显示只剩下一个多G，该信谁的 开发也有过一些难以想象的苹果的bug，Xcode编译程序导致访问 nib 文件必现crash 最近又发现 Mac (Mojave 10.14.6) 上的文件系统，更新文件增加文件当前Finder界面并不会立刻更新，而是需要来回切换才会显示，有时即使这样也不会显示新增的文件。 不得不使用命令来操作文件了 也有可能是我的15年的老古董支撑不起强大的操作系统了 作为程序员，本不应该依赖UI界面的，正好借此开始逐渐脱离图形界面操作 希望这些只是苹果在创新尝试的小纰漏，也希望苹果能有更多的进步创新。","categories":[],"tags":[]},{"title":"Django Restful","slug":"Django-Restful","date":"2020-03-04T03:35:33.000Z","updated":"2020-03-04T07:46:05.445Z","comments":true,"path":"2020/03/04/Django-Restful/","link":"","permalink":"onegoon.store/2020/03/04/Django-Restful/","excerpt":"","text":"python 搭建rest API有两大主流 Django 与 Flask Django 较重 组件齐全 Flask 较轻，灵活 我选择先入手Django，原因是生态。 后续有能力还会在来Flask RESTRepresentational state transfer 表现层状态转换 Roy Thomas Fielding博士提出的一种网络服务架构的风格。也叫restful。 表现层状态转换是基于超文本传输协议之上的一族约束和属性，是一种设计网络服务的软件构建风格。 客户端发出请求以统一资源标识符访问和操作网络资源 当前在三种主流的Web服务实现方案中，因为REST模式与复杂的SOAP和XML-RPC相比更加简洁，越来越多的Web服务开始采用REST风格设计和实现。 Django rest 框架 django-rest-framework 官方文档 https://www.django-rest-framework.org/","categories":[],"tags":[]},{"title":"SQL","slug":"SQL","date":"2020-03-03T10:35:43.000Z","updated":"2020-03-03T14:25:37.665Z","comments":true,"path":"2020/03/03/SQL/","link":"","permalink":"onegoon.store/2020/03/03/SQL/","excerpt":"","text":"MYSQL安装 mysql下载：https://dev.mysql.com/downloads/ navicat下载：https://www.navicat.com.cn/ 出现个问题 .bash_profile 添加路径 但是在terminal上无效，还需要手动 设置PATH PATH=${PATH}:/usr/local/mysql/bin mysql -u root -p -u 代表user 这里用户名为root -p password 使用MYSQL的图形化程序navicat","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"onegoon.store/tags/SQL/"}]},{"title":"有一个想法","slug":"有一个想法","date":"2020-03-02T12:25:17.000Z","updated":"2020-03-02T14:30:22.560Z","comments":true,"path":"2020/03/02/有一个想法/","link":"","permalink":"onegoon.store/2020/03/02/有一个想法/","excerpt":"","text":"有一个想法。 想搭建一个平台，后端到前端产品到UI","categories":[],"tags":[{"name":"架构","slug":"架构","permalink":"onegoon.store/tags/架构/"}]},{"title":"Django入门","slug":"Django入门","date":"2020-02-28T02:39:28.000Z","updated":"2020-03-06T05:04:15.130Z","comments":true,"path":"2020/02/28/Django入门/","link":"","permalink":"onegoon.store/2020/02/28/Django入门/","excerpt":"","text":"Django 初级篇虚拟环境 virtualenv1virtualenv venv -p python3 为project提供独立的python环境。pycharm默认开启的 开启 1source venv/bin/activate 开启后 命令行最左端有(venv)字样 代表虚拟环境开启 1(venv) ➜ PlanA 注意开启后 所有操作都在venv环境下进行的 使用 python 而不是python3，pip而不是pip3 关闭 1deactivate 安装 Djangoinstall django ```12345678就此环境搭建完毕##### 开始构建项目（Project）我的第一个项目`PlanA````django-admin startproject PlanA 12345678910PlanA/ &lt;-- higher level folder├── PlanA &lt;-- django project folder （ `startproject` 命令创建的）│ ├── PlanA│ │ ├── __init__.py│ │ ├── asgi.py│ │ ├── settings.py│ │ ├── urls.py│ │ └── wsgi.py│ └── manage.py└── venv &lt;-- virtual environment folder 这些目录和文件的用处是：(django 文档给出) The outer mysite/ root directory is a container for your project. Its name doesn’t matter to Django; you can rename it to anything you like. manage.py: 一个让你用各种方式管理 Django 项目的命令行工具。你可以阅读 django-admin and manage.py 获取所有 manage.py 的细节。 里面一层的 mysite/ 目录包含你的项目，它是一个纯 Python 包。它的名字就是当你引用它内部任何东西时需要用到的 Python 包名。 (比如 mysite.urls). mysite/__init__.py：一个空文件，告诉 Python 这个目录应该被认为是一个 Python 包。如果你是 Python 初学者，阅读官方文档中的 更多关于包的知识。 mysite/settings.py：Django 项目的配置文件。如果你想知道这个文件是如何工作的，请查看 Django 配置 了解细节。 mysite/urls.py：Django 项目的 URL 声明，就像你网站的“目录”。阅读 URL调度器 文档来获取更多关于 URL 的内容。 mysite/asgi.py: An entry-point for ASGI-compatible web servers to serve your project. See How to deploy with ASGI for more details. mysite/wsgi.py：作为你的项目的运行在 WSGI 兼容的Web服务器上的入口。阅读 如何使用 WSGI 进行部署 了解更多细节。 一个project可以包含很多个app 同一个app可以存在与多个project中 创建appstartapp boards ```123456789101112注意这次我们用的是`startapp`.├── __init__.py├── admin.py├── apps.py├── migrations│ └── __init__.py├── models.py├── tests.py└── views.py PlanA/ &lt;– higher level folder├── boards &lt;– our new django app!│ ├── init.py│ ├── admin.py│ ├── apps.py│ ├── migrations│ │ └── init.py│ ├── models.py│ ├── tests.py│ └── views.py├── PlanA &lt;– django project folder （ startproject 命令创建的）│ ├── PlanA│ │ ├── init.py│ │ ├── asgi.py│ │ ├── settings.py│ │ ├── urls.py│ │ └── wsgi.py│ └── manage.py└── venv &lt;– virtual environment folder 123456##### 本地运行服务 8000端口``` python manage.py runserver 更换端口默认情况下，runserver 命令会将服务器设置为监听本机内部 IP 的 8000 端口。 如果你想更换服务器的监听端口，请使用命令行参数。举个例子，下面的命令会使服务器监听 8080 端口： 1$ python manage.py runserver 8080 如果你想要修改服务器监听的IP，在端口之前输入新的。比如，为了监听所有服务器的公开IP（这你运行 Vagrant 或想要向网络上的其它电脑展示你的成果时很有用），使用： 1$ python manage.py runserver 0:8000 0 是 0.0.0.0 的简写。完整的关于开发服务器的文档可以在 :djamdin:runserver 参考文档中找到。 新版django 的路由 path与re_path1234urlpatterns = [ path(&apos;polls/&apos;, include(&apos;polls.urls&apos;)), path(&apos;admin/&apos;, admin.site.urls),] 以前是url path() 参数： route¶route 是一个匹配 URL 的准则（类似正则表达式）。当 Django 响应一个请求时，它会从 urlpatterns 的第一项开始，按顺序依次匹配列表中的项，直到找到匹配的项。 这些准则不会匹配 GET 和 POST 参数或域名。例如，URLconf 在处理请求 https://www.example.com/myapp/ 时，它会尝试匹配 myapp/ 。处理请求 https://www.example.com/myapp/?page=3 时，也只会尝试匹配 myapp/。 path() 参数： view¶当 Django 找到了一个匹配的准则，就会调用这个特定的视图函数，并传入一个 HttpRequest 对象作为第一个参数，被“捕获”的参数以关键字参数的形式传入。稍后，我们会给出一个例子。 path() 参数： kwargs¶任意个关键字参数可以作为一个字典传递给目标视图函数。本教程中不会使用这一特性。 path() 参数： name¶为你的 URL 取名能使你在 Django 的任意地方唯一地引用它，尤其是在模板中。这个有用的特性允许你只改一个文件就能全局地修改某个 URL 模式。 当你了解了基本的请求和响应流程后，请阅读 教程的第 2 部分 开始使用数据库. 数据库迁移manage.py makemigrations```12```python manage.py migrate 资料https://tutorial.djangogirls.org/zh/ 一个gitbook，难度较低的教程，如果有基础不建议看 https://github.com/TwoWater/Python 国人写的教程，能够快速了解陌生的信息 https://docs.djangoproject.com/ 官方文档，更新较为即时，语言可选中文。 https://simpleisbetterthancomplex.com/series/beginners-guide/1.11/ 新人友善的博客，带你一步一步完成一个论坛类的project 17年写的有些东西需要更新。","categories":[],"tags":[{"name":"python, django","slug":"python-django","permalink":"onegoon.store/tags/python-django/"}]},{"title":"19年总结","slug":"19年总结","date":"2019-12-31T15:22:21.000Z","updated":"2019-12-31T15:24:47.970Z","comments":true,"path":"2019/12/31/19年总结/","link":"","permalink":"onegoon.store/2019/12/31/19年总结/","excerpt":"","text":"工作上技术长进学会了如何团队开发 iOS的技能点 点的比较多 ​ 单元测试写了不少，对单元测试有了另一番的理解感悟，code容易片面，test来补全 ​ Swift 较为精进毕竟日常开发，编译了Swift并阅读了部分源码，如网络部分，json解析，数据结构部分等 ​ Darwin-xnu, pthread, dyld, Foundation.混个面熟吧。 ​ 从头跟了MonkeyDev的逆向，会使用逆向工具，更加了解了iOS&amp;macOS的运行机制， ​ 对MachO的解析也实践了一段，配合阅读《程序员的自我修养》《深入理解计算系统》。 ​ 汇编，要想理解、验证一些底层的东西还是绕不开汇编的。但是Risc实在太精简了 数据结构与算法，多数的还处于思想上。能手写的只有那几个排序，，base huffman实现了一个解压缩算法 操作系统也学了些，了解CPU的一些机制流水线，多发射，超标量，分支预测，多核协作等。 网络 组内分享了一次TCP/IP，继续阅读POSIX的源码，目前仅完成了用户态 socket的demo，其实还是在应用层。后续要深入到内核态看看。 Wireshark真是个好东西，大家能看到的才有说服力。 生活上程序员离开了电脑如丧失了大脑，编码之外的其他人情世故似乎不差了不少。（也仅可能是我吧，个人感受）。 跑了不少次医院，对医院的流程，对世故的处理有所感悟 篮球，年龄将长，身体越发虚弱~~··。适当锻炼，身体倍棒，远离CS 马上要见家长了，紧张","categories":[],"tags":[]},{"title":"mac socket","slug":"mac-socket","date":"2019-12-27T08:14:01.000Z","updated":"2019-12-29T15:06:49.204Z","comments":true,"path":"2019/12/27/mac-socket/","link":"","permalink":"onegoon.store/2019/12/27/mac-socket/","excerpt":"","text":"### 套接字接口的起源 套接字接口是加州大学伯克利分校的研究员在20世纪80年代早期提出来的。因为这个原因，它也常被叫做伯克利套接字。伯克利的研究者使得套接字接口适用于任何底层的协议。第一个实现的就是针对TCP/IP协议的，他们把它包括在Unix 4.2BSD的内核里，并且分发给许多学校和实验室。这在因特网的历史上是一个重大事件。几乎一夜之间，成千上万的人们接触到了TCP/IP和它的源代码。它引起了巨大的轰动，并激发了新的网络和网络互联研究的浪潮 节选自 《深入理解计算机系统》第三版 伯克利 Berkeley Core Foundation通过CFNetwork提供了封装套接字的CFSocket和CFStream，此外还进一步提供了一些协议的封装，例如CFFTP、CFHTTP等 BSD套接字是XNU中所有网络组件的核心 socket 函数客户端和服务器使用socket函数来创建一个套接字描述符 在&lt;sys/socket.h&gt;中定义int socket(int, int, int); 在bsd&gt;kern&gt;syscalls.master 中97 AUE_SOCKET ALL { int socket(int domain, int type, int protocol); } 若成功则为非负描述符，若出错则为-1 12345678910/** domain 套接字域（地址/协议族）通常指的是 AF（Address Family）或者PF(Protocol Family)表示第2层或第3层地址对应的套接字地址模式。常见的IP协议，即PF_INET或AF_INET传统上使用的是AF_*常量，PF_*常量只不过是通过AF_*常量#define得到的* type * protocol 所在文件bsd &gt; netinet &gt; in.h Xcode里面也能看见注释*/int socket(int domain, int type, int protocol) 1234567891011// socket.h 114~123/* * Types */#define SOCK_STREAM 1 /* stream socket */#define SOCK_DGRAM 2 /* datagram socket */#define SOCK_RAW 3 /* raw-protocol interface */#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)#define SOCK_RDM 4 /* reliably-delivered message */#endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */#define SOCK_SEQPACKET 5 /* sequenced packet stream */ 123456789101112131415// socket.h 528~586/* * Address families. */#define AF_UNSPEC 0 /* unspecified */#define AF_UNIX 1 /* local to host (pipes) */#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)#define AF_LOCAL AF_UNIX /* backward compatibility */#endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */#define AF_INET 2 /* internetwork: UDP, TCP, etc. */...#define AF_INET6 30 /* IPv6 */... 1234567891011// socket.h 632~680/* * Protocol families, same as address families for now. */#define PF_UNSPEC AF_UNSPEC#define PF_LOCAL AF_LOCAL#define PF_UNIX PF_LOCAL /* backward compatibility */#define PF_INET AF_INET...#define PF_INET6 AF_INET6...","categories":[],"tags":[{"name":"socket","slug":"socket","permalink":"onegoon.store/tags/socket/"}]},{"title":"Mac app socket server","slug":"Mac-app-socket-server","date":"2019-12-26T08:24:57.000Z","updated":"2019-12-27T01:24:50.949Z","comments":true,"path":"2019/12/26/Mac-app-socket-server/","link":"","permalink":"onegoon.store/2019/12/26/Mac-app-socket-server/","excerpt":"在macOS app 上创建socket server 发现创建失败 抛出异常代码如下 1try checkNotMinus1&#123; Darwin.bind(ipv4Socket, addrPtr, UInt32(MemoryLayout&lt;sockaddr_in&gt;.size)) 123456789/// 封装检测是否为-1/// errno 为Darwin的错误码enum SocketError: Error &#123; case socketCreateFailed(Int32) &#125;@discardableResultfunc checkNotMinus1(_ f: () -&gt; Int32) throws -&gt; Int32 &#123; let r = f() guard r != -1 else &#123; throw SocketError.socketCreateFailed(errno) &#125; return r&#125; catch中的error 为ssocketCreateFailed(1) 也就是errno为1","text":"在macOS app 上创建socket server 发现创建失败 抛出异常代码如下 1try checkNotMinus1&#123; Darwin.bind(ipv4Socket, addrPtr, UInt32(MemoryLayout&lt;sockaddr_in&gt;.size)) 123456789/// 封装检测是否为-1/// errno 为Darwin的错误码enum SocketError: Error &#123; case socketCreateFailed(Int32) &#125;@discardableResultfunc checkNotMinus1(_ f: () -&gt; Int32) throws -&gt; Int32 &#123; let r = f() guard r != -1 else &#123; throw SocketError.socketCreateFailed(errno) &#125; return r&#125; catch中的error 为ssocketCreateFailed(1) 也就是errno为1 ⌘左键 进入代码定义（Jump to Definition） 发现只有定义没有注释，能看到他是定义在Darwin中 打开Darwin-xnu 找到errno.h (&lt;sys/errno.h&gt;) 发现错误码为1 对应 Operation not permitted 我是使用Xcode的版本 Version 11.2.1 (11B500) 新版Xcode会把app 的能力单独一页列出来 当我勾选Network 的 Server选项后 bind成功了","categories":[],"tags":[{"name":"Mac OS","slug":"Mac-OS","permalink":"onegoon.store/tags/Mac-OS/"}]},{"title":"SF Symbols","slug":"SF-Symbols","date":"2019-12-26T05:06:06.000Z","updated":"2019-12-26T05:56:36.424Z","comments":true,"path":"2019/12/26/SF-Symbols/","link":"","permalink":"onegoon.store/2019/12/26/SF-Symbols/","excerpt":"SF Symbols Mac上的一款app 有超1500个符号可供使用，也可以自定义符号 可以导出文件，用sketch编辑","text":"SF Symbols Mac上的一款app 有超1500个符号可供使用，也可以自定义符号 可以导出文件，用sketch编辑 UIKit 提供了两种API，一种是使用系统符号，另外一种是自定义 init(systemName:) init(systemName:compatibleWith:) init(systemName:withConfiguration:)methods of UIImage. init(named:) init(named:in:compatibleWith:) init(named:in:with:) 1let image = UIImage(systemName: \"square.and.arrow.up\") image 会加载对应的符号 也可以自定义符号 Assets.xcassets / + / New Symbol Image Set / 拖拽编辑好的SVG文件到xcode中 效果如图 1let image = UIImage(systemName: \"arrowupfill\") #####link refer Creating Custom Symbol Images for Your App","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"onegoon.store/tags/iOS/"}]},{"title":"iOS URLSession Request","slug":"iOS-URLSession-Request","date":"2019-11-27T15:14:13.000Z","updated":"2019-11-27T16:22:22.736Z","comments":true,"path":"2019/11/27/iOS-URLSession-Request/","link":"","permalink":"onegoon.store/2019/11/27/iOS-URLSession-Request/","excerpt":"概览","text":"概览 参考资料 Foundation","categories":[],"tags":[]},{"title":"抓包","slug":"抓包","date":"2019-10-01T07:25:18.000Z","updated":"2019-12-26T09:18:01.212Z","comments":true,"path":"2019/10/01/抓包/","link":"","permalink":"onegoon.store/2019/10/01/抓包/","excerpt":"网络已成为当下人类的必需品，身为开发人员势必了解其原理，无论是正向开发，抑或是逆向攻击。 网络抓包，是对网络传输中的数据包进行抓取。而后可对其进行分析。 正向开发中，我们可以通过抓包进行验证发送的数据是否正确，如验证发送的次数，host，path，header等。 也可以对特定的请求模拟给出特定的响应结果，检查发送端在得到响应后的行为是否符合预期，比如验证一些业务场景极少发生的场景以及边界等。","text":"网络已成为当下人类的必需品，身为开发人员势必了解其原理，无论是正向开发，抑或是逆向攻击。 网络抓包，是对网络传输中的数据包进行抓取。而后可对其进行分析。 正向开发中，我们可以通过抓包进行验证发送的数据是否正确，如验证发送的次数，host，path，header等。 也可以对特定的请求模拟给出特定的响应结果，检查发送端在得到响应后的行为是否符合预期，比如验证一些业务场景极少发生的场景以及边界等。 抓包工具Charles (青花瓷/花瓶)Charles 支持截取 HTTP/HTTPS Charles 抓包原理是将自己设为代理。 代理相当于一个中间人 ​ 客户端发送的所有数据都会先通过代理，然后由代理发送给服务器。 ​ 服务器收到请求后，将相应消息返回给代理，然后由代理发送给客户端。 对客户端来说代理就是服务器，对服务器来说代理就是客户端，所以两者都不会感知网络被拦截了。这就是中间人攻击的原理。 拦截iPhone上的网络请求 将Charles的代理功能打开 设置代理并勾选”Enable transparent HTTP proxying” 查看ip， Help -&gt; Local IP Address . 或者去网络设置中去查看，如今可以看到两种地址，短的是IPv4,长的是IPv6. 在iphone上，设置网络代理为Charles启动的代理服务器。","categories":[],"tags":[{"name":"http","slug":"http","permalink":"onegoon.store/tags/http/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-05-28T14:39:18.000Z","updated":"2019-05-28T14:39:18.000Z","comments":true,"path":"2019/05/28/hello-world/","link":"","permalink":"onegoon.store/2019/05/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}